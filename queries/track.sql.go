// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: track.sql

package queries

import (
	"context"
)

const getTracks = `-- name: GetTracks :many
SELECT
  t.track_id,
  owner_id,
  title,
  is_unlisted,

  repost_count,
  save_count as favorite_count,

  (
    SELECT count(*) > 0
    FROM reposts
    WHERE $1 > 0
      AND user_id = $1
      AND repost_type = 'track'
      AND repost_item_id = t.track_id
      AND is_delete = false
  ) AS has_current_user_reposted

FROM tracks t
JOIN aggregate_track using (track_id)
WHERE is_available = true
  AND (is_unlisted = false OR owner_id = $1)
  AND (
    t.track_id = $2
    OR t.owner_id = $3
  )
ORDER BY t.track_id
`

type GetTracksParams struct {
	MyID    interface{} `json:"my_id"`
	TrackID int32       `json:"track_id"`
	OwnerID int32       `json:"owner_id"`
}

type GetTracksRow struct {
	TrackID                int32   `json:"track_id"`
	OwnerID                int32   `json:"owner_id"`
	Title                  *string `json:"title"`
	IsUnlisted             bool    `json:"is_unlisted"`
	RepostCount            int32   `json:"repost_count"`
	FavoriteCount          int32   `json:"favorite_count"`
	HasCurrentUserReposted bool    `json:"has_current_user_reposted"`
}

func (q *Queries) GetTracks(ctx context.Context, arg GetTracksParams) ([]GetTracksRow, error) {
	rows, err := q.db.Query(ctx, getTracks, arg.MyID, arg.TrackID, arg.OwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTracksRow
	for rows.Next() {
		var i GetTracksRow
		if err := rows.Scan(
			&i.TrackID,
			&i.OwnerID,
			&i.Title,
			&i.IsUnlisted,
			&i.RepostCount,
			&i.FavoriteCount,
			&i.HasCurrentUserReposted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
