// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: user.sql

package queries

import (
	"context"
)

const getUsers = `-- name: GetUsers :many
SELECT
  u.user_id,
  handle,
  wallet,
  name,
  bio,
  location,
  follower_count,
  track_count,

  (
    SELECT count(*) > 0
    FROM follows
    WHERE $1 > 0
      AND follower_user_id = $1
      AND followee_user_id = u.user_id
      AND is_delete = false
  ) AS does_current_user_follow,

  (
    SELECT count(*) > 0
    FROM follows
    WHERE $1 > 0
      AND followee_user_id = $1
      AND follower_user_id = u.user_id
      AND is_delete = false
  ) AS does_follow_current_user

FROM users u
JOIN aggregate_user using (user_id)
WHERE is_deactivated = false
  AND (
    handle_lc = lower($2)
    OR u.user_id = ANY($3::int[])
  )
ORDER BY u.user_id
`

type GetUsersParams struct {
	MyID   interface{} `json:"my_id"`
	Handle string      `json:"handle"`
	Ids    []int32     `json:"ids"`
}

type GetUsersRow struct {
	UserID                int32   `json:"user_id"`
	Handle                *string `json:"handle"`
	Wallet                *string `json:"wallet"`
	Name                  *string `json:"name"`
	Bio                   *string `json:"bio"`
	Location              *string `json:"location"`
	FollowerCount         *int64  `json:"follower_count"`
	TrackCount            *int64  `json:"track_count"`
	DoesCurrentUserFollow bool    `json:"does_current_user_follow"`
	DoesFollowCurrentUser bool    `json:"does_follow_current_user"`
}

func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) ([]GetUsersRow, error) {
	rows, err := q.db.Query(ctx, getUsers, arg.MyID, arg.Handle, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersRow
	for rows.Next() {
		var i GetUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Handle,
			&i.Wallet,
			&i.Name,
			&i.Bio,
			&i.Location,
			&i.FollowerCount,
			&i.TrackCount,
			&i.DoesCurrentUserFollow,
			&i.DoesFollowCurrentUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
