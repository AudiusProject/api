// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package queries

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type Challengetype string

const (
	ChallengetypeBoolean   Challengetype = "boolean"
	ChallengetypeNumeric   Challengetype = "numeric"
	ChallengetypeAggregate Challengetype = "aggregate"
	ChallengetypeTrending  Challengetype = "trending"
)

func (e *Challengetype) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Challengetype(s)
	case string:
		*e = Challengetype(s)
	default:
		return fmt.Errorf("unsupported scan type for Challengetype: %T", src)
	}
	return nil
}

type NullChallengetype struct {
	Challengetype Challengetype `json:"challengetype"`
	Valid         bool          `json:"valid"` // Valid is true if Challengetype is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullChallengetype) Scan(value interface{}) error {
	if value == nil {
		ns.Challengetype, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Challengetype.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullChallengetype) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Challengetype), nil
}

type DelistEntity string

const (
	DelistEntityTRACKS DelistEntity = "TRACKS"
	DelistEntityUSERS  DelistEntity = "USERS"
)

func (e *DelistEntity) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DelistEntity(s)
	case string:
		*e = DelistEntity(s)
	default:
		return fmt.Errorf("unsupported scan type for DelistEntity: %T", src)
	}
	return nil
}

type NullDelistEntity struct {
	DelistEntity DelistEntity `json:"delist_entity"`
	Valid        bool         `json:"valid"` // Valid is true if DelistEntity is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDelistEntity) Scan(value interface{}) error {
	if value == nil {
		ns.DelistEntity, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DelistEntity.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDelistEntity) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DelistEntity), nil
}

type DelistTrackReason string

const (
	DelistTrackReasonDMCA                    DelistTrackReason = "DMCA"
	DelistTrackReasonACR                     DelistTrackReason = "ACR"
	DelistTrackReasonMANUAL                  DelistTrackReason = "MANUAL"
	DelistTrackReasonACRCOUNTERNOTICE        DelistTrackReason = "ACR_COUNTER_NOTICE"
	DelistTrackReasonDMCARETRACTION          DelistTrackReason = "DMCA_RETRACTION"
	DelistTrackReasonDMCACOUNTERNOTICE       DelistTrackReason = "DMCA_COUNTER_NOTICE"
	DelistTrackReasonDMCAANDACRCOUNTERNOTICE DelistTrackReason = "DMCA_AND_ACR_COUNTER_NOTICE"
)

func (e *DelistTrackReason) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DelistTrackReason(s)
	case string:
		*e = DelistTrackReason(s)
	default:
		return fmt.Errorf("unsupported scan type for DelistTrackReason: %T", src)
	}
	return nil
}

type NullDelistTrackReason struct {
	DelistTrackReason DelistTrackReason `json:"delist_track_reason"`
	Valid             bool              `json:"valid"` // Valid is true if DelistTrackReason is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDelistTrackReason) Scan(value interface{}) error {
	if value == nil {
		ns.DelistTrackReason, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DelistTrackReason.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDelistTrackReason) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DelistTrackReason), nil
}

type DelistUserReason string

const (
	DelistUserReasonSTRIKETHRESHOLD DelistUserReason = "STRIKE_THRESHOLD"
	DelistUserReasonCOPYRIGHTSCHOOL DelistUserReason = "COPYRIGHT_SCHOOL"
	DelistUserReasonMANUAL          DelistUserReason = "MANUAL"
)

func (e *DelistUserReason) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DelistUserReason(s)
	case string:
		*e = DelistUserReason(s)
	default:
		return fmt.Errorf("unsupported scan type for DelistUserReason: %T", src)
	}
	return nil
}

type NullDelistUserReason struct {
	DelistUserReason DelistUserReason `json:"delist_user_reason"`
	Valid            bool             `json:"valid"` // Valid is true if DelistUserReason is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDelistUserReason) Scan(value interface{}) error {
	if value == nil {
		ns.DelistUserReason, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DelistUserReason.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDelistUserReason) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DelistUserReason), nil
}

type ProofStatus string

const (
	ProofStatusUnresolved ProofStatus = "unresolved"
	ProofStatusPass       ProofStatus = "pass"
	ProofStatusFail       ProofStatus = "fail"
)

func (e *ProofStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProofStatus(s)
	case string:
		*e = ProofStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ProofStatus: %T", src)
	}
	return nil
}

type NullProofStatus struct {
	ProofStatus ProofStatus `json:"proof_status"`
	Valid       bool        `json:"valid"` // Valid is true if ProofStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProofStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ProofStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProofStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProofStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProofStatus), nil
}

type Reposttype string

const (
	ReposttypeTrack    Reposttype = "track"
	ReposttypePlaylist Reposttype = "playlist"
	ReposttypeAlbum    Reposttype = "album"
)

func (e *Reposttype) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Reposttype(s)
	case string:
		*e = Reposttype(s)
	default:
		return fmt.Errorf("unsupported scan type for Reposttype: %T", src)
	}
	return nil
}

type NullReposttype struct {
	Reposttype Reposttype `json:"reposttype"`
	Valid      bool       `json:"valid"` // Valid is true if Reposttype is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullReposttype) Scan(value interface{}) error {
	if value == nil {
		ns.Reposttype, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Reposttype.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullReposttype) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Reposttype), nil
}

type Savetype string

const (
	SavetypeTrack    Savetype = "track"
	SavetypePlaylist Savetype = "playlist"
	SavetypeAlbum    Savetype = "album"
)

func (e *Savetype) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Savetype(s)
	case string:
		*e = Savetype(s)
	default:
		return fmt.Errorf("unsupported scan type for Savetype: %T", src)
	}
	return nil
}

type NullSavetype struct {
	Savetype Savetype `json:"savetype"`
	Valid    bool     `json:"valid"` // Valid is true if Savetype is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSavetype) Scan(value interface{}) error {
	if value == nil {
		ns.Savetype, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Savetype.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSavetype) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Savetype), nil
}

type Skippedtransactionlevel string

const (
	SkippedtransactionlevelNode    Skippedtransactionlevel = "node"
	SkippedtransactionlevelNetwork Skippedtransactionlevel = "network"
)

func (e *Skippedtransactionlevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Skippedtransactionlevel(s)
	case string:
		*e = Skippedtransactionlevel(s)
	default:
		return fmt.Errorf("unsupported scan type for Skippedtransactionlevel: %T", src)
	}
	return nil
}

type NullSkippedtransactionlevel struct {
	Skippedtransactionlevel Skippedtransactionlevel `json:"skippedtransactionlevel"`
	Valid                   bool                    `json:"valid"` // Valid is true if Skippedtransactionlevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSkippedtransactionlevel) Scan(value interface{}) error {
	if value == nil {
		ns.Skippedtransactionlevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Skippedtransactionlevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSkippedtransactionlevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Skippedtransactionlevel), nil
}

type UsdcPurchaseAccessType string

const (
	UsdcPurchaseAccessTypeStream   UsdcPurchaseAccessType = "stream"
	UsdcPurchaseAccessTypeDownload UsdcPurchaseAccessType = "download"
)

func (e *UsdcPurchaseAccessType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UsdcPurchaseAccessType(s)
	case string:
		*e = UsdcPurchaseAccessType(s)
	default:
		return fmt.Errorf("unsupported scan type for UsdcPurchaseAccessType: %T", src)
	}
	return nil
}

type NullUsdcPurchaseAccessType struct {
	UsdcPurchaseAccessType UsdcPurchaseAccessType `json:"usdc_purchase_access_type"`
	Valid                  bool                   `json:"valid"` // Valid is true if UsdcPurchaseAccessType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUsdcPurchaseAccessType) Scan(value interface{}) error {
	if value == nil {
		ns.UsdcPurchaseAccessType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UsdcPurchaseAccessType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUsdcPurchaseAccessType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UsdcPurchaseAccessType), nil
}

type UsdcPurchaseContentType string

const (
	UsdcPurchaseContentTypeTrack    UsdcPurchaseContentType = "track"
	UsdcPurchaseContentTypePlaylist UsdcPurchaseContentType = "playlist"
	UsdcPurchaseContentTypeAlbum    UsdcPurchaseContentType = "album"
)

func (e *UsdcPurchaseContentType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UsdcPurchaseContentType(s)
	case string:
		*e = UsdcPurchaseContentType(s)
	default:
		return fmt.Errorf("unsupported scan type for UsdcPurchaseContentType: %T", src)
	}
	return nil
}

type NullUsdcPurchaseContentType struct {
	UsdcPurchaseContentType UsdcPurchaseContentType `json:"usdc_purchase_content_type"`
	Valid                   bool                    `json:"valid"` // Valid is true if UsdcPurchaseContentType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUsdcPurchaseContentType) Scan(value interface{}) error {
	if value == nil {
		ns.UsdcPurchaseContentType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UsdcPurchaseContentType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUsdcPurchaseContentType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UsdcPurchaseContentType), nil
}

type WalletChain string

const (
	WalletChainEth WalletChain = "eth"
	WalletChainSol WalletChain = "sol"
)

func (e *WalletChain) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WalletChain(s)
	case string:
		*e = WalletChain(s)
	default:
		return fmt.Errorf("unsupported scan type for WalletChain: %T", src)
	}
	return nil
}

type NullWalletChain struct {
	WalletChain WalletChain `json:"wallet_chain"`
	Valid       bool        `json:"valid"` // Valid is true if WalletChain is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWalletChain) Scan(value interface{}) error {
	if value == nil {
		ns.WalletChain, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WalletChain.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWalletChain) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WalletChain), nil
}

type AggregateDailyAppNameMetric struct {
	ID              int32            `json:"id"`
	ApplicationName string           `json:"application_name"`
	Count           int32            `json:"count"`
	Timestamp       pgtype.Date      `json:"timestamp"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
}

type AggregateDailyTotalUsersMetric struct {
	ID            int32            `json:"id"`
	Count         int32            `json:"count"`
	Timestamp     pgtype.Date      `json:"timestamp"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	PersonalCount *int32           `json:"personal_count"`
}

type AggregateDailyUniqueUsersMetric struct {
	ID            int32            `json:"id"`
	Count         int32            `json:"count"`
	Timestamp     pgtype.Date      `json:"timestamp"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	SummedCount   *int32           `json:"summed_count"`
	PersonalCount *int32           `json:"personal_count"`
}

type AggregateIntervalPlay struct {
	TrackID           int32            `json:"track_id"`
	Genre             *string          `json:"genre"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	WeekListenCounts  int64            `json:"week_listen_counts"`
	MonthListenCounts int64            `json:"month_listen_counts"`
}

type AggregateMonthlyAppNameMetric struct {
	ID              int32            `json:"id"`
	ApplicationName string           `json:"application_name"`
	Count           int32            `json:"count"`
	Timestamp       pgtype.Date      `json:"timestamp"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
}

type AggregateMonthlyPlay struct {
	PlayItemID int32       `json:"play_item_id"`
	Timestamp  pgtype.Date `json:"timestamp"`
	Count      int32       `json:"count"`
	Country    string      `json:"country"`
}

type AggregateMonthlyTotalUsersMetric struct {
	ID            int32            `json:"id"`
	Count         int32            `json:"count"`
	Timestamp     pgtype.Date      `json:"timestamp"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	PersonalCount *int32           `json:"personal_count"`
}

type AggregateMonthlyUniqueUsersMetric struct {
	ID            int32            `json:"id"`
	Count         int32            `json:"count"`
	Timestamp     pgtype.Date      `json:"timestamp"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	SummedCount   *int32           `json:"summed_count"`
	PersonalCount *int32           `json:"personal_count"`
}

type AggregatePlay struct {
	PlayItemID int32  `json:"play_item_id"`
	Count      *int64 `json:"count"`
}

type AggregatePlaylist struct {
	PlaylistID  int32  `json:"playlist_id"`
	IsAlbum     *bool  `json:"is_album"`
	RepostCount *int32 `json:"repost_count"`
	SaveCount   *int32 `json:"save_count"`
}

type AggregateTrack struct {
	TrackID      int32  `json:"track_id"`
	RepostCount  int32  `json:"repost_count"`
	SaveCount    int32  `json:"save_count"`
	CommentCount *int32 `json:"comment_count"`
}

type AggregateUser struct {
	UserID             int32   `json:"user_id"`
	TrackCount         *int64  `json:"track_count"`
	PlaylistCount      *int64  `json:"playlist_count"`
	AlbumCount         *int64  `json:"album_count"`
	FollowerCount      *int64  `json:"follower_count"`
	FollowingCount     *int64  `json:"following_count"`
	RepostCount        *int64  `json:"repost_count"`
	TrackSaveCount     *int64  `json:"track_save_count"`
	SupporterCount     int32   `json:"supporter_count"`
	SupportingCount    int32   `json:"supporting_count"`
	DominantGenre      *string `json:"dominant_genre"`
	DominantGenreCount *int32  `json:"dominant_genre_count"`
	Score              *int32  `json:"score"`
}

type AggregateUserTip struct {
	SenderUserID   int32 `json:"sender_user_id"`
	ReceiverUserID int32 `json:"receiver_user_id"`
	Amount         int64 `json:"amount"`
}

type AlbumPriceHistory struct {
	PlaylistID      int32            `json:"playlist_id"`
	Splits          []byte           `json:"splits"`
	TotalPriceCents int64            `json:"total_price_cents"`
	Blocknumber     int32            `json:"blocknumber"`
	BlockTimestamp  pgtype.Timestamp `json:"block_timestamp"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
}

type AlembicVersion struct {
	VersionNum string `json:"version_num"`
}

type AntiAbuseBlockedUser struct {
	HandleLc  string           `json:"handle_lc"`
	IsBlocked bool             `json:"is_blocked"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

type AppNameMetric struct {
	ApplicationName string           `json:"application_name"`
	Count           int32            `json:"count"`
	Timestamp       pgtype.Timestamp `json:"timestamp"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
	ID              int64            `json:"id"`
	Ip              *string          `json:"ip"`
}

type AppNameMetricsAllTime struct {
	Name  string `json:"name"`
	Count int64  `json:"count"`
}

type AppNameMetricsTrailingMonth struct {
	Name  string `json:"name"`
	Count int64  `json:"count"`
}

type AppNameMetricsTrailingWeek struct {
	Name  string `json:"name"`
	Count int64  `json:"count"`
}

type AssociatedWallet struct {
	ID          int32       `json:"id"`
	UserID      int32       `json:"user_id"`
	Wallet      string      `json:"wallet"`
	Blockhash   string      `json:"blockhash"`
	Blocknumber int32       `json:"blocknumber"`
	IsCurrent   bool        `json:"is_current"`
	IsDelete    bool        `json:"is_delete"`
	Chain       WalletChain `json:"chain"`
}

type AudioTransactionsHistory struct {
	UserBank             string           `json:"user_bank"`
	Slot                 int32            `json:"slot"`
	Signature            string           `json:"signature"`
	TransactionType      string           `json:"transaction_type"`
	Method               string           `json:"method"`
	CreatedAt            pgtype.Timestamp `json:"created_at"`
	UpdatedAt            pgtype.Timestamp `json:"updated_at"`
	TransactionCreatedAt pgtype.Timestamp `json:"transaction_created_at"`
	Change               pgtype.Numeric   `json:"change"`
	Balance              pgtype.Numeric   `json:"balance"`
	TxMetadata           *string          `json:"tx_metadata"`
}

type AudiusDataTx struct {
	Signature string `json:"signature"`
	Slot      int32  `json:"slot"`
}

type Block struct {
	Blockhash  string  `json:"blockhash"`
	Parenthash *string `json:"parenthash"`
	IsCurrent  *bool   `json:"is_current"`
	Number     *int32  `json:"number"`
}

type Bmg struct {
	CopyTitle    *string `json:"copy_title"`
	CopyMediaUrl *string `json:"copy_media_url"`
	ID           *string `json:"id"`
	Permalink    *string `json:"permalink"`
	Acr          *string `json:"acr"`
	Available    *string `json:"available"`
	Plays        *string `json:"plays"`
	AssetTitle   *string `json:"asset_title"`
}

type Challenge struct {
	ID            string        `json:"id"`
	Type          Challengetype `json:"type"`
	Amount        string        `json:"amount"`
	Active        bool          `json:"active"`
	StepCount     *int32        `json:"step_count"`
	StartingBlock *int32        `json:"starting_block"`
	WeeklyPool    *int32        `json:"weekly_pool"`
	CooldownDays  *int32        `json:"cooldown_days"`
}

type ChallengeDisbursement struct {
	ChallengeID string             `json:"challenge_id"`
	UserID      int32              `json:"user_id"`
	Specifier   string             `json:"specifier"`
	Signature   string             `json:"signature"`
	Slot        int32              `json:"slot"`
	Amount      string             `json:"amount"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

type ChallengeListenStreak struct {
	UserID         int32            `json:"user_id"`
	LastListenDate pgtype.Timestamp `json:"last_listen_date"`
	ListenStreak   int32            `json:"listen_streak"`
}

type ChallengeProfileCompletion struct {
	UserID             int32 `json:"user_id"`
	ProfileDescription bool  `json:"profile_description"`
	ProfileName        bool  `json:"profile_name"`
	ProfilePicture     bool  `json:"profile_picture"`
	ProfileCoverPhoto  bool  `json:"profile_cover_photo"`
	Follows            bool  `json:"follows"`
	Favorites          bool  `json:"favorites"`
	Reposts            bool  `json:"reposts"`
}

type Chat struct {
	ChatID                 string           `json:"chat_id"`
	CreatedAt              pgtype.Timestamp `json:"created_at"`
	LastMessageAt          pgtype.Timestamp `json:"last_message_at"`
	LastMessage            *string          `json:"last_message"`
	LastMessageIsPlaintext *bool            `json:"last_message_is_plaintext"`
}

type ChatBan struct {
	UserID    int32            `json:"user_id"`
	IsBanned  bool             `json:"is_banned"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

type ChatBlast struct {
	BlastID             string             `json:"blast_id"`
	FromUserID          int32              `json:"from_user_id"`
	Audience            string             `json:"audience"`
	AudienceContentID   *int32             `json:"audience_content_id"`
	Plaintext           string             `json:"plaintext"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	AudienceContentType *string            `json:"audience_content_type"`
}

type ChatBlockedUser struct {
	BlockerUserID int32            `json:"blocker_user_id"`
	BlockeeUserID int32            `json:"blockee_user_id"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
}

type ChatMember struct {
	ChatID           string           `json:"chat_id"`
	UserID           int32            `json:"user_id"`
	ClearedHistoryAt pgtype.Timestamp `json:"cleared_history_at"`
	InvitedByUserID  int32            `json:"invited_by_user_id"`
	InviteCode       string           `json:"invite_code"`
	LastActiveAt     pgtype.Timestamp `json:"last_active_at"`
	UnreadCount      int32            `json:"unread_count"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	IsHidden         bool             `json:"is_hidden"`
}

type ChatMessage struct {
	MessageID  string           `json:"message_id"`
	ChatID     string           `json:"chat_id"`
	UserID     int32            `json:"user_id"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	Ciphertext *string          `json:"ciphertext"`
	BlastID    *string          `json:"blast_id"`
}

type ChatMessageReaction struct {
	UserID    int32            `json:"user_id"`
	MessageID string           `json:"message_id"`
	Reaction  string           `json:"reaction"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

type ChatPermission struct {
	UserID    int32            `json:"user_id"`
	Permits   string           `json:"permits"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
	Allowed   bool             `json:"allowed"`
}

type CidDatum struct {
	Cid  string  `json:"cid"`
	Type *string `json:"type"`
	Data []byte  `json:"data"`
}

// Stores collectibles data for users
type Collectible struct {
	// User ID of the person who owns the collectibles
	UserID int32 `json:"user_id"`
	// Data about the collectibles
	Data []byte `json:"data"`
	// Blockhash of the most recent block that changed the collectibles data
	Blockhash string `json:"blockhash"`
	// Block number of the most recent block that changed the collectibles data
	Blocknumber int32              `json:"blocknumber"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

type Comment struct {
	CommentID       int32            `json:"comment_id"`
	Text            string           `json:"text"`
	UserID          int32            `json:"user_id"`
	EntityID        int32            `json:"entity_id"`
	EntityType      string           `json:"entity_type"`
	TrackTimestampS *int64           `json:"track_timestamp_s"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
	IsDelete        *bool            `json:"is_delete"`
	IsVisible       *bool            `json:"is_visible"`
	IsEdited        *bool            `json:"is_edited"`
	Txhash          string           `json:"txhash"`
	Blockhash       string           `json:"blockhash"`
	Blocknumber     *int32           `json:"blocknumber"`
}

type CommentMention struct {
	CommentID   int32            `json:"comment_id"`
	UserID      int32            `json:"user_id"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	IsDelete    *bool            `json:"is_delete"`
	Txhash      string           `json:"txhash"`
	Blockhash   string           `json:"blockhash"`
	Blocknumber *int32           `json:"blocknumber"`
}

type CommentNotificationSetting struct {
	UserID     int32            `json:"user_id"`
	EntityID   int32            `json:"entity_id"`
	EntityType string           `json:"entity_type"`
	IsMuted    *bool            `json:"is_muted"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
}

type CommentReaction struct {
	CommentID   int32            `json:"comment_id"`
	UserID      int32            `json:"user_id"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	IsDelete    *bool            `json:"is_delete"`
	Txhash      string           `json:"txhash"`
	Blockhash   string           `json:"blockhash"`
	Blocknumber *int32           `json:"blocknumber"`
}

type CommentReport struct {
	CommentID   int32            `json:"comment_id"`
	UserID      int32            `json:"user_id"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	IsDelete    *bool            `json:"is_delete"`
	Txhash      string           `json:"txhash"`
	Blockhash   string           `json:"blockhash"`
	Blocknumber *int32           `json:"blocknumber"`
}

type CommentThread struct {
	CommentID       int32 `json:"comment_id"`
	ParentCommentID int32 `json:"parent_comment_id"`
}

type CoreAppState struct {
	BlockHeight int64            `json:"block_height"`
	AppHash     []byte           `json:"app_hash"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
}

type CoreBlock struct {
	Rowid     int64            `json:"rowid"`
	Height    int64            `json:"height"`
	ChainID   string           `json:"chain_id"`
	Hash      string           `json:"hash"`
	Proposer  string           `json:"proposer"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

type CoreDbMigration struct {
	ID        string             `json:"id"`
	AppliedAt pgtype.Timestamptz `json:"applied_at"`
}

type CoreIndexedBlock struct {
	Blockhash  string  `json:"blockhash"`
	Parenthash *string `json:"parenthash"`
	ChainID    string  `json:"chain_id"`
	Height     int32   `json:"height"`
	PlaysSlot  *int32  `json:"plays_slot"`
	EmBlock    *int32  `json:"em_block"`
}

type CoreTransaction struct {
	Rowid       int64            `json:"rowid"`
	BlockID     int64            `json:"block_id"`
	Index       int32            `json:"index"`
	TxHash      string           `json:"tx_hash"`
	Transaction []byte           `json:"transaction"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
}

type CoreTxDecoded struct {
	ID          int64              `json:"id"`
	BlockHeight int64              `json:"block_height"`
	TxIndex     int32              `json:"tx_index"`
	TxHash      string             `json:"tx_hash"`
	TxType      string             `json:"tx_type"`
	TxData      []byte             `json:"tx_data"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

type CoreTxDecodedPlay struct {
	ID        int64              `json:"id"`
	TxHash    string             `json:"tx_hash"`
	UserID    string             `json:"user_id"`
	TrackID   string             `json:"track_id"`
	PlayedAt  pgtype.Timestamptz `json:"played_at"`
	Signature string             `json:"signature"`
	City      *string            `json:"city"`
	Region    *string            `json:"region"`
	Country   *string            `json:"country"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type CoreTxStat struct {
	ID          int32            `json:"id"`
	TxType      string           `json:"tx_type"`
	TxHash      string           `json:"tx_hash"`
	BlockHeight int64            `json:"block_height"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
}

type CoreValidator struct {
	Rowid        int32  `json:"rowid"`
	PubKey       string `json:"pub_key"`
	Endpoint     string `json:"endpoint"`
	EthAddress   string `json:"eth_address"`
	CometAddress string `json:"comet_address"`
	EthBlock     string `json:"eth_block"`
	NodeType     string `json:"node_type"`
	SpID         string `json:"sp_id"`
	CometPubKey  string `json:"comet_pub_key"`
}

type Country struct {
	Iso       string  `json:"iso"`
	Name      string  `json:"name"`
	Nicename  string  `json:"nicename"`
	Iso3      *string `json:"iso3"`
	Numcode   *int16  `json:"numcode"`
	Phonecode int32   `json:"phonecode"`
}

type DashboardWalletUser struct {
	Wallet      string           `json:"wallet"`
	UserID      int32            `json:"user_id"`
	IsDelete    bool             `json:"is_delete"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	Blockhash   *string          `json:"blockhash"`
	Blocknumber *int32           `json:"blocknumber"`
	Txhash      string           `json:"txhash"`
}

type DelistStatusCursor struct {
	Host      string             `json:"host"`
	Entity    DelistEntity       `json:"entity"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type DeveloperApp struct {
	Address          string           `json:"address"`
	Blockhash        *string          `json:"blockhash"`
	Blocknumber      *int32           `json:"blocknumber"`
	UserID           *int32           `json:"user_id"`
	Name             string           `json:"name"`
	IsPersonalAccess bool             `json:"is_personal_access"`
	IsDelete         bool             `json:"is_delete"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	Txhash           string           `json:"txhash"`
	IsCurrent        bool             `json:"is_current"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	Description      *string          `json:"description"`
	ImageUrl         *string          `json:"image_url"`
}

// Tracks who has access to encrypted emails
type EmailAccess struct {
	ID int32 `json:"id"`
	// The user ID of the email owner
	EmailOwnerUserID int32 `json:"email_owner_user_id"`
	// The user ID of the person granted access
	ReceivingUserID int32 `json:"receiving_user_id"`
	// The user ID of the person who granted access
	GrantorUserID int32 `json:"grantor_user_id"`
	// The symmetric key (SK) encrypted for the receiving user
	EncryptedKey string             `json:"encrypted_key"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	IsInitial    bool               `json:"is_initial"`
}

// Stores encrypted email addresses
type EncryptedEmail struct {
	ID int32 `json:"id"`
	// The user ID of the email owner
	EmailOwnerUserID int32 `json:"email_owner_user_id"`
	// The encrypted email address (base64 encoded)
	EncryptedEmail string             `json:"encrypted_email"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

type EthBlock struct {
	LastScannedBlock int32            `json:"last_scanned_block"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
}

type Follow struct {
	Blockhash      *string          `json:"blockhash"`
	Blocknumber    *int32           `json:"blocknumber"`
	FollowerUserID int32            `json:"follower_user_id"`
	FolloweeUserID int32            `json:"followee_user_id"`
	IsCurrent      bool             `json:"is_current"`
	IsDelete       bool             `json:"is_delete"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	Txhash         string           `json:"txhash"`
	Slot           *int32           `json:"slot"`
}

type Grant struct {
	Blockhash      *string          `json:"blockhash"`
	Blocknumber    *int32           `json:"blocknumber"`
	GranteeAddress string           `json:"grantee_address"`
	UserID         int32            `json:"user_id"`
	IsRevoked      bool             `json:"is_revoked"`
	IsCurrent      bool             `json:"is_current"`
	IsApproved     *bool            `json:"is_approved"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	Txhash         string           `json:"txhash"`
}

type HourlyPlayCount struct {
	HourlyTimestamp pgtype.Timestamp `json:"hourly_timestamp"`
	PlayCount       int32            `json:"play_count"`
}

type IndexingCheckpoint struct {
	Tablename      string  `json:"tablename"`
	LastCheckpoint int32   `json:"last_checkpoint"`
	Signature      *string `json:"signature"`
}

type Milestone struct {
	ID          int32            `json:"id"`
	Name        string           `json:"name"`
	Threshold   int32            `json:"threshold"`
	Blocknumber *int32           `json:"blocknumber"`
	Slot        *int32           `json:"slot"`
	Timestamp   pgtype.Timestamp `json:"timestamp"`
}

type MutedUser struct {
	MutedUserID int32            `json:"muted_user_id"`
	UserID      int32            `json:"user_id"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	IsDelete    *bool            `json:"is_delete"`
	Txhash      string           `json:"txhash"`
	Blockhash   string           `json:"blockhash"`
	Blocknumber *int32           `json:"blocknumber"`
}

type Notification struct {
	ID          int32            `json:"id"`
	Specifier   string           `json:"specifier"`
	GroupID     string           `json:"group_id"`
	Type        string           `json:"type"`
	Slot        *int32           `json:"slot"`
	Blocknumber *int32           `json:"blocknumber"`
	Timestamp   pgtype.Timestamp `json:"timestamp"`
	Data        []byte           `json:"data"`
	UserIds     []int32          `json:"user_ids"`
	TypeV2      *string          `json:"type_v2"`
}

type NotificationSeen struct {
	UserID      int32            `json:"user_id"`
	SeenAt      pgtype.Timestamp `json:"seen_at"`
	Blocknumber *int32           `json:"blocknumber"`
	Blockhash   *string          `json:"blockhash"`
	Txhash      *string          `json:"txhash"`
}

type PaymentRouterTx struct {
	Signature string           `json:"signature"`
	Slot      int32            `json:"slot"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

type Play struct {
	ID         int32            `json:"id"`
	UserID     *int32           `json:"user_id"`
	Source     *string          `json:"source"`
	PlayItemID int32            `json:"play_item_id"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
	Slot       *int32           `json:"slot"`
	Signature  *string          `json:"signature"`
	City       *string          `json:"city"`
	Region     *string          `json:"region"`
	Country    *string          `json:"country"`
}

type Playlist struct {
	Blockhash                   *string          `json:"blockhash"`
	Blocknumber                 *int32           `json:"blocknumber"`
	PlaylistID                  int32            `json:"playlist_id"`
	PlaylistOwnerID             int32            `json:"playlist_owner_id"`
	IsAlbum                     bool             `json:"is_album"`
	IsPrivate                   bool             `json:"is_private"`
	PlaylistName                *string          `json:"playlist_name"`
	PlaylistContents            PlaylistContents `json:"playlist_contents"`
	PlaylistImageMultihash      *string          `json:"playlist_image_multihash"`
	IsCurrent                   bool             `json:"is_current"`
	IsDelete                    bool             `json:"is_delete"`
	Description                 *string          `json:"description"`
	CreatedAt                   pgtype.Timestamp `json:"created_at"`
	Upc                         *string          `json:"upc"`
	UpdatedAt                   pgtype.Timestamp `json:"updated_at"`
	PlaylistImageSizesMultihash *string          `json:"playlist_image_sizes_multihash"`
	Txhash                      string           `json:"txhash"`
	LastAddedTo                 pgtype.Timestamp `json:"last_added_to"`
	Slot                        *int32           `json:"slot"`
	MetadataMultihash           *string          `json:"metadata_multihash"`
	IsImageAutogenerated        bool             `json:"is_image_autogenerated"`
	StreamConditions            []byte           `json:"stream_conditions"`
	DdexApp                     *string          `json:"ddex_app"`
	DdexReleaseIds              []byte           `json:"ddex_release_ids"`
	Artists                     []byte           `json:"artists"`
	CopyrightLine               []byte           `json:"copyright_line"`
	ProducerCopyrightLine       []byte           `json:"producer_copyright_line"`
	ParentalWarningType         *string          `json:"parental_warning_type"`
	IsScheduledRelease          bool             `json:"is_scheduled_release"`
	ReleaseDate                 pgtype.Timestamp `json:"release_date"`
	IsStreamGated               *bool            `json:"is_stream_gated"`
}

type PlaylistRoute struct {
	Slug        string `json:"slug"`
	TitleSlug   string `json:"title_slug"`
	CollisionID int32  `json:"collision_id"`
	OwnerID     int32  `json:"owner_id"`
	PlaylistID  int32  `json:"playlist_id"`
	IsCurrent   bool   `json:"is_current"`
	Blockhash   string `json:"blockhash"`
	Blocknumber int32  `json:"blocknumber"`
	Txhash      string `json:"txhash"`
}

type PlaylistSeen struct {
	UserID      int32            `json:"user_id"`
	PlaylistID  int32            `json:"playlist_id"`
	SeenAt      pgtype.Timestamp `json:"seen_at"`
	IsCurrent   bool             `json:"is_current"`
	Blocknumber *int32           `json:"blocknumber"`
	Blockhash   *string          `json:"blockhash"`
	Txhash      *string          `json:"txhash"`
}

type PlaylistTrack struct {
	PlaylistID int32              `json:"playlist_id"`
	TrackID    int32              `json:"track_id"`
	IsRemoved  bool               `json:"is_removed"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

type Reaction struct {
	ID            int32            `json:"id"`
	ReactionValue int32            `json:"reaction_value"`
	SenderWallet  string           `json:"sender_wallet"`
	ReactionType  string           `json:"reaction_type"`
	ReactedTo     string           `json:"reacted_to"`
	Timestamp     pgtype.Timestamp `json:"timestamp"`
	Blocknumber   *int32           `json:"blocknumber"`
}

type RelatedArtist struct {
	UserID              int32            `json:"user_id"`
	RelatedArtistUserID int32            `json:"related_artist_user_id"`
	Score               float64          `json:"score"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
}

type Remix struct {
	ParentTrackID int32 `json:"parent_track_id"`
	ChildTrackID  int32 `json:"child_track_id"`
}

type ReportedComment struct {
	ReportedCommentID int32            `json:"reported_comment_id"`
	UserID            int32            `json:"user_id"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	Txhash            string           `json:"txhash"`
	Blockhash         string           `json:"blockhash"`
	Blocknumber       *int32           `json:"blocknumber"`
}

type Repost struct {
	Blockhash        *string          `json:"blockhash"`
	Blocknumber      *int32           `json:"blocknumber"`
	UserID           int32            `json:"user_id"`
	RepostItemID     int32            `json:"repost_item_id"`
	RepostType       Reposttype       `json:"repost_type"`
	IsCurrent        bool             `json:"is_current"`
	IsDelete         bool             `json:"is_delete"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	Txhash           string           `json:"txhash"`
	Slot             *int32           `json:"slot"`
	IsRepostOfRepost bool             `json:"is_repost_of_repost"`
}

type RevertBlock struct {
	Blocknumber int32  `json:"blocknumber"`
	PrevRecords []byte `json:"prev_records"`
}

type RewardManagerTx struct {
	Signature string           `json:"signature"`
	Slot      int32            `json:"slot"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

type RouteMetric struct {
	RoutePath   string           `json:"route_path"`
	Version     string           `json:"version"`
	QueryString string           `json:"query_string"`
	Count       int32            `json:"count"`
	Timestamp   pgtype.Timestamp `json:"timestamp"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	ID          int64            `json:"id"`
	Ip          *string          `json:"ip"`
}

type RouteMetricsAllTime struct {
	UniqueCount int64 `json:"unique_count"`
	Count       int64 `json:"count"`
}

type RouteMetricsDayBucket struct {
	UniqueCount int64           `json:"unique_count"`
	Count       int64           `json:"count"`
	Time        pgtype.Interval `json:"time"`
}

type RouteMetricsMonthBucket struct {
	UniqueCount int64           `json:"unique_count"`
	Count       int64           `json:"count"`
	Time        pgtype.Interval `json:"time"`
}

type RouteMetricsTrailingMonth struct {
	UniqueCount int64 `json:"unique_count"`
	Count       int64 `json:"count"`
}

type RouteMetricsTrailingWeek struct {
	UniqueCount int64 `json:"unique_count"`
	Count       int64 `json:"count"`
}

type RpcCursor struct {
	RelayedBy string           `json:"relayed_by"`
	RelayedAt pgtype.Timestamp `json:"relayed_at"`
}

type RpcError struct {
	Sig         string           `json:"sig"`
	RpcLogJson  []byte           `json:"rpc_log_json"`
	ErrorText   string           `json:"error_text"`
	ErrorCount  int32            `json:"error_count"`
	LastAttempt pgtype.Timestamp `json:"last_attempt"`
}

type RpcLog struct {
	RelayedAt  pgtype.Timestamp `json:"relayed_at"`
	FromWallet string           `json:"from_wallet"`
	Rpc        []byte           `json:"rpc"`
	Sig        string           `json:"sig"`
	RelayedBy  string           `json:"relayed_by"`
	AppliedAt  pgtype.Timestamp `json:"applied_at"`
}

type Safe struct {
	Blockhash      *string          `json:"blockhash"`
	Blocknumber    *int32           `json:"blocknumber"`
	UserID         int32            `json:"user_id"`
	SaveItemID     int32            `json:"save_item_id"`
	SaveType       Savetype         `json:"save_type"`
	IsCurrent      bool             `json:"is_current"`
	IsDelete       bool             `json:"is_delete"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	Txhash         string           `json:"txhash"`
	Slot           *int32           `json:"slot"`
	IsSaveOfRepost bool             `json:"is_save_of_repost"`
}

type SchemaMigration struct {
	Version string `json:"version"`
}

type SchemaVersion struct {
	FileName  string             `json:"file_name"`
	Md5       *string            `json:"md5"`
	AppliedAt pgtype.Timestamptz `json:"applied_at"`
}

type SkippedTransaction struct {
	ID          int32                   `json:"id"`
	Blocknumber int32                   `json:"blocknumber"`
	Blockhash   string                  `json:"blockhash"`
	Txhash      string                  `json:"txhash"`
	CreatedAt   pgtype.Timestamp        `json:"created_at"`
	UpdatedAt   pgtype.Timestamp        `json:"updated_at"`
	Level       Skippedtransactionlevel `json:"level"`
}

type SlaAuditorVersionDatum struct {
	ID           int32              `json:"id"`
	NodeEndpoint string             `json:"node_endpoint"`
	NodeVersion  string             `json:"node_version"`
	MinVersion   string             `json:"min_version"`
	Owner        string             `json:"owner"`
	Ok           bool               `json:"ok"`
	Timestamp    pgtype.Timestamptz `json:"timestamp"`
}

type SlaNodeReport struct {
	ID             int32  `json:"id"`
	Address        string `json:"address"`
	BlocksProposed int32  `json:"blocks_proposed"`
	SlaRollupID    *int32 `json:"sla_rollup_id"`
}

type SlaRollup struct {
	ID         int32            `json:"id"`
	TxHash     string           `json:"tx_hash"`
	BlockStart int64            `json:"block_start"`
	BlockEnd   int64            `json:"block_end"`
	Time       pgtype.Timestamp `json:"time"`
}

type SplTokenTx struct {
	LastScannedSlot int32              `json:"last_scanned_slot"`
	Signature       string             `json:"signature"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

type Stem struct {
	ParentTrackID int32 `json:"parent_track_id"`
	ChildTrackID  int32 `json:"child_track_id"`
}

type StorageProof struct {
	ID              int32       `json:"id"`
	BlockHeight     int64       `json:"block_height"`
	Address         string      `json:"address"`
	Cid             *string     `json:"cid"`
	ProofSignature  *string     `json:"proof_signature"`
	Proof           *string     `json:"proof"`
	ProverAddresses []string    `json:"prover_addresses"`
	Status          ProofStatus `json:"status"`
}

type StorageProofPeer struct {
	ID              int32    `json:"id"`
	BlockHeight     int64    `json:"block_height"`
	ProverAddresses []string `json:"prover_addresses"`
}

type Subscription struct {
	Blockhash    *string          `json:"blockhash"`
	Blocknumber  *int32           `json:"blocknumber"`
	SubscriberID int32            `json:"subscriber_id"`
	UserID       int32            `json:"user_id"`
	IsCurrent    bool             `json:"is_current"`
	IsDelete     bool             `json:"is_delete"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	Txhash       string           `json:"txhash"`
}

type SupporterRankUp struct {
	Slot           int32 `json:"slot"`
	SenderUserID   int32 `json:"sender_user_id"`
	ReceiverUserID int32 `json:"receiver_user_id"`
	Rank           int32 `json:"rank"`
}

type TagTrackUser struct {
	Tag     interface{} `json:"tag"`
	TrackID int32       `json:"track_id"`
	OwnerID int32       `json:"owner_id"`
}

type Track struct {
	Blockhash                          *string          `json:"blockhash"`
	TrackID                            int32            `json:"track_id"`
	IsCurrent                          bool             `json:"is_current"`
	IsDelete                           bool             `json:"is_delete"`
	OwnerID                            int32            `json:"owner_id"`
	Title                              *string          `json:"title"`
	CoverArt                           *string          `json:"cover_art"`
	Tags                               *string          `json:"tags"`
	Genre                              *string          `json:"genre"`
	Mood                               *string          `json:"mood"`
	CreditsSplits                      *string          `json:"credits_splits"`
	CreateDate                         *string          `json:"create_date"`
	FileType                           *string          `json:"file_type"`
	MetadataMultihash                  *string          `json:"metadata_multihash"`
	Blocknumber                        *int32           `json:"blocknumber"`
	CreatedAt                          pgtype.Timestamp `json:"created_at"`
	Description                        *string          `json:"description"`
	Isrc                               *string          `json:"isrc"`
	Iswc                               *string          `json:"iswc"`
	License                            *string          `json:"license"`
	UpdatedAt                          pgtype.Timestamp `json:"updated_at"`
	CoverArtSizes                      *string          `json:"cover_art_sizes"`
	IsUnlisted                         bool             `json:"is_unlisted"`
	FieldVisibility                    json.RawMessage  `json:"field_visibility"`
	RouteID                            *string          `json:"route_id"`
	StemOf                             []byte           `json:"stem_of"`
	RemixOf                            []byte           `json:"remix_of"`
	Txhash                             string           `json:"txhash"`
	Slot                               *int32           `json:"slot"`
	IsAvailable                        bool             `json:"is_available"`
	StreamConditions                   UsageConditions  `json:"stream_conditions"`
	TrackCid                           *string          `json:"track_cid"`
	IsPlaylistUpload                   bool             `json:"is_playlist_upload"`
	Duration                           *int32           `json:"duration"`
	AiAttributionUserID                *int32           `json:"ai_attribution_user_id"`
	PreviewCid                         *string          `json:"preview_cid"`
	AudioUploadID                      *string          `json:"audio_upload_id"`
	PreviewStartSeconds                *float64         `json:"preview_start_seconds"`
	ReleaseDate                        pgtype.Timestamp `json:"release_date"`
	TrackSegments                      []byte           `json:"track_segments"`
	IsScheduledRelease                 bool             `json:"is_scheduled_release"`
	IsDownloadable                     bool             `json:"is_downloadable"`
	DownloadConditions                 UsageConditions  `json:"download_conditions"`
	IsOriginalAvailable                bool             `json:"is_original_available"`
	OrigFileCid                        *string          `json:"orig_file_cid"`
	OrigFilename                       *string          `json:"orig_filename"`
	PlaylistsContainingTrack           []int32          `json:"playlists_containing_track"`
	PlacementHosts                     *string          `json:"placement_hosts"`
	DdexApp                            *string          `json:"ddex_app"`
	DdexReleaseIds                     json.RawMessage  `json:"ddex_release_ids"`
	Artists                            json.RawMessage  `json:"artists"`
	ResourceContributors               json.RawMessage  `json:"resource_contributors"`
	IndirectResourceContributors       json.RawMessage  `json:"indirect_resource_contributors"`
	RightsController                   json.RawMessage  `json:"rights_controller"`
	CopyrightLine                      json.RawMessage  `json:"copyright_line"`
	ProducerCopyrightLine              json.RawMessage  `json:"producer_copyright_line"`
	ParentalWarningType                *string          `json:"parental_warning_type"`
	PlaylistsPreviouslyContainingTrack []byte           `json:"playlists_previously_containing_track"`
	AllowedApiKeys                     []string         `json:"allowed_api_keys"`
	Bpm                                *float64         `json:"bpm"`
	MusicalKey                         *string          `json:"musical_key"`
	AudioAnalysisErrorCount            int32            `json:"audio_analysis_error_count"`
	IsCustomBpm                        *bool            `json:"is_custom_bpm"`
	IsCustomMusicalKey                 *bool            `json:"is_custom_musical_key"`
	CommentsDisabled                   *bool            `json:"comments_disabled"`
	PinnedCommentID                    *int32           `json:"pinned_comment_id"`
	// Title of the original song if this track is a cover
	CoverOriginalSongTitle *string `json:"cover_original_song_title"`
	// Artist of the original song if this track is a cover
	CoverOriginalArtist *string `json:"cover_original_artist"`
	// Indicates whether the track is owned by the user for publishing payouts
	IsOwnedByUser   bool  `json:"is_owned_by_user"`
	IsStreamGated   *bool `json:"is_stream_gated"`
	IsDownloadGated *bool `json:"is_download_gated"`
}

type TrackDelistStatus struct {
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	TrackID   int32              `json:"track_id"`
	OwnerID   int32              `json:"owner_id"`
	TrackCid  string             `json:"track_cid"`
	Delisted  bool               `json:"delisted"`
	Reason    DelistTrackReason  `json:"reason"`
}

type TrackDownload struct {
	Txhash        string           `json:"txhash"`
	Blocknumber   int32            `json:"blocknumber"`
	ParentTrackID int32            `json:"parent_track_id"`
	TrackID       int32            `json:"track_id"`
	UserID        *int32           `json:"user_id"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	City          *string          `json:"city"`
	Region        *string          `json:"region"`
	Country       *string          `json:"country"`
}

type TrackPriceHistory struct {
	TrackID         int32                  `json:"track_id"`
	Splits          []byte                 `json:"splits"`
	TotalPriceCents int64                  `json:"total_price_cents"`
	Blocknumber     int32                  `json:"blocknumber"`
	BlockTimestamp  pgtype.Timestamp       `json:"block_timestamp"`
	CreatedAt       pgtype.Timestamp       `json:"created_at"`
	Access          UsdcPurchaseAccessType `json:"access"`
}

type TrackRoute struct {
	Slug        string `json:"slug"`
	TitleSlug   string `json:"title_slug"`
	CollisionID int32  `json:"collision_id"`
	OwnerID     int32  `json:"owner_id"`
	TrackID     int32  `json:"track_id"`
	IsCurrent   bool   `json:"is_current"`
	Blockhash   string `json:"blockhash"`
	Blocknumber int32  `json:"blocknumber"`
	Txhash      string `json:"txhash"`
}

type TrackTrendingScore struct {
	TrackID   int32            `json:"track_id"`
	Type      string           `json:"type"`
	Genre     *string          `json:"genre"`
	Version   string           `json:"version"`
	TimeRange string           `json:"time_range"`
	Score     float64          `json:"score"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

type TrendingParam struct {
	TrackID            int32            `json:"track_id"`
	ReleaseDate        pgtype.Timestamp `json:"release_date"`
	Genre              *string          `json:"genre"`
	OwnerID            int32            `json:"owner_id"`
	PlayCount          *int64           `json:"play_count"`
	OwnerFollowerCount *int64           `json:"owner_follower_count"`
	RepostCount        int32            `json:"repost_count"`
	SaveCount          int32            `json:"save_count"`
	RepostWeekCount    int64            `json:"repost_week_count"`
	RepostMonthCount   int64            `json:"repost_month_count"`
	RepostYearCount    int64            `json:"repost_year_count"`
	SaveWeekCount      int64            `json:"save_week_count"`
	SaveMonthCount     int64            `json:"save_month_count"`
	SaveYearCount      int64            `json:"save_year_count"`
	Karma              int64            `json:"karma"`
}

type TrendingResult struct {
	UserID  int32       `json:"user_id"`
	ID      *string     `json:"id"`
	Rank    int32       `json:"rank"`
	Type    string      `json:"type"`
	Version string      `json:"version"`
	Week    pgtype.Date `json:"week"`
}

type UsdcPurchase struct {
	Slot         int32                   `json:"slot"`
	Signature    string                  `json:"signature"`
	BuyerUserID  int32                   `json:"buyer_user_id"`
	SellerUserID int32                   `json:"seller_user_id"`
	Amount       int64                   `json:"amount"`
	ContentType  UsdcPurchaseContentType `json:"content_type"`
	ContentID    int32                   `json:"content_id"`
	CreatedAt    pgtype.Timestamp        `json:"created_at"`
	UpdatedAt    pgtype.Timestamp        `json:"updated_at"`
	ExtraAmount  int64                   `json:"extra_amount"`
	Access       UsdcPurchaseAccessType  `json:"access"`
	City         *string                 `json:"city"`
	Region       *string                 `json:"region"`
	Country      *string                 `json:"country"`
	Vendor       *string                 `json:"vendor"`
	Splits       []byte                  `json:"splits"`
}

type UsdcTransactionsHistory struct {
	UserBank             string           `json:"user_bank"`
	Slot                 int32            `json:"slot"`
	Signature            string           `json:"signature"`
	TransactionType      string           `json:"transaction_type"`
	Method               string           `json:"method"`
	CreatedAt            pgtype.Timestamp `json:"created_at"`
	UpdatedAt            pgtype.Timestamp `json:"updated_at"`
	TransactionCreatedAt pgtype.Timestamp `json:"transaction_created_at"`
	Change               pgtype.Numeric   `json:"change"`
	Balance              pgtype.Numeric   `json:"balance"`
	TxMetadata           *string          `json:"tx_metadata"`
}

type UsdcUserBankAccount struct {
	Signature       string           `json:"signature"`
	EthereumAddress string           `json:"ethereum_address"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	BankAccount     string           `json:"bank_account"`
}

type User struct {
	Blockhash              *string          `json:"blockhash"`
	UserID                 int32            `json:"user_id"`
	IsCurrent              bool             `json:"is_current"`
	Handle                 *string          `json:"handle"`
	Wallet                 *string          `json:"wallet"`
	Name                   *string          `json:"name"`
	ProfilePicture         *string          `json:"profile_picture"`
	CoverPhoto             *string          `json:"cover_photo"`
	Bio                    *string          `json:"bio"`
	Location               *string          `json:"location"`
	MetadataMultihash      *string          `json:"metadata_multihash"`
	CreatorNodeEndpoint    *string          `json:"creator_node_endpoint"`
	Blocknumber            *int32           `json:"blocknumber"`
	IsVerified             bool             `json:"is_verified"`
	CreatedAt              pgtype.Timestamp `json:"created_at"`
	UpdatedAt              pgtype.Timestamp `json:"updated_at"`
	HandleLc               *string          `json:"handle_lc"`
	CoverPhotoSizes        *string          `json:"cover_photo_sizes"`
	ProfilePictureSizes    *string          `json:"profile_picture_sizes"`
	PrimaryID              *int32           `json:"primary_id"`
	SecondaryIds           []int32          `json:"secondary_ids"`
	ReplicaSetUpdateSigner *string          `json:"replica_set_update_signer"`
	HasCollectibles        bool             `json:"has_collectibles"`
	Txhash                 string           `json:"txhash"`
	PlaylistLibrary        json.RawMessage  `json:"playlist_library"`
	IsDeactivated          bool             `json:"is_deactivated"`
	Slot                   *int32           `json:"slot"`
	UserStorageAccount     *string          `json:"user_storage_account"`
	UserAuthorityAccount   *string          `json:"user_authority_account"`
	ArtistPickTrackID      *int32           `json:"artist_pick_track_id"`
	IsAvailable            bool             `json:"is_available"`
	IsStorageV2            bool             `json:"is_storage_v2"`
	AllowAiAttribution     bool             `json:"allow_ai_attribution"`
	SplUsdcPayoutWallet    *string          `json:"spl_usdc_payout_wallet"`
	TwitterHandle          *string          `json:"twitter_handle"`
	InstagramHandle        *string          `json:"instagram_handle"`
	TiktokHandle           *string          `json:"tiktok_handle"`
	VerifiedWithTwitter    *bool            `json:"verified_with_twitter"`
	VerifiedWithInstagram  *bool            `json:"verified_with_instagram"`
	VerifiedWithTiktok     *bool            `json:"verified_with_tiktok"`
	Website                *string          `json:"website"`
	Donation               *string          `json:"donation"`
}

type UserBalance struct {
	UserID                      int32            `json:"user_id"`
	Balance                     string           `json:"balance"`
	CreatedAt                   pgtype.Timestamp `json:"created_at"`
	UpdatedAt                   pgtype.Timestamp `json:"updated_at"`
	AssociatedWalletsBalance    string           `json:"associated_wallets_balance"`
	Waudio                      *string          `json:"waudio"`
	AssociatedSolWalletsBalance string           `json:"associated_sol_wallets_balance"`
}

type UserBalanceChange struct {
	UserID          int32            `json:"user_id"`
	Blocknumber     int32            `json:"blocknumber"`
	CurrentBalance  string           `json:"current_balance"`
	PreviousBalance string           `json:"previous_balance"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
}

type UserBankAccount struct {
	Signature       string           `json:"signature"`
	EthereumAddress string           `json:"ethereum_address"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	BankAccount     string           `json:"bank_account"`
}

type UserBankTx struct {
	Signature string           `json:"signature"`
	Slot      int32            `json:"slot"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

type UserChallenge struct {
	ChallengeID          string             `json:"challenge_id"`
	UserID               int32              `json:"user_id"`
	Specifier            string             `json:"specifier"`
	IsComplete           bool               `json:"is_complete"`
	CurrentStepCount     *int32             `json:"current_step_count"`
	CompletedBlocknumber *int32             `json:"completed_blocknumber"`
	Amount               int32              `json:"amount"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	CompletedAt          pgtype.Timestamp   `json:"completed_at"`
}

type UserDelistStatus struct {
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UserID    int32              `json:"user_id"`
	Delisted  bool               `json:"delisted"`
	Reason    DelistUserReason   `json:"reason"`
}

type UserEvent struct {
	ID           int32   `json:"id"`
	Blockhash    *string `json:"blockhash"`
	Blocknumber  *int32  `json:"blocknumber"`
	IsCurrent    bool    `json:"is_current"`
	UserID       int32   `json:"user_id"`
	Referrer     *int32  `json:"referrer"`
	IsMobileUser bool    `json:"is_mobile_user"`
	Slot         *int32  `json:"slot"`
}

type UserListeningHistory struct {
	UserID           int32  `json:"user_id"`
	ListeningHistory []byte `json:"listening_history"`
}

type UserPayoutWalletHistory struct {
	UserID              int32            `json:"user_id"`
	SplUsdcPayoutWallet *string          `json:"spl_usdc_payout_wallet"`
	Blocknumber         int32            `json:"blocknumber"`
	BlockTimestamp      pgtype.Timestamp `json:"block_timestamp"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
}

type UserPubkey struct {
	UserID       int32  `json:"user_id"`
	PubkeyBase64 string `json:"pubkey_base64"`
}

type UserTip struct {
	Slot           int32            `json:"slot"`
	Signature      string           `json:"signature"`
	SenderUserID   int32            `json:"sender_user_id"`
	ReceiverUserID int32            `json:"receiver_user_id"`
	Amount         int64            `json:"amount"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
}
