// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: get_grants.sql

package dbv1

import (
	"context"
	"time"

	"bridgerton.audius.co/trashid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getGrantsForGranteeAddress = `-- name: GetGrantsForGranteeAddress :many
SELECT
  g.user_id,
  g.grantee_address,
  g.is_revoked,
  g.is_approved,
  g.created_at,
  g.updated_at,
  u.user_id as grantee_user_id
FROM grants g
JOIN users u ON u.wallet = g.grantee_address
WHERE g.grantee_address = $1
  AND g.is_current = true
  AND g.is_revoked = $2
  AND $3::boolean IS NULL OR g.is_approved = $3
ORDER BY g.created_at DESC
`

type GetGrantsForGranteeAddressParams struct {
	GranteeAddress string      `json:"grantee_address"`
	IsRevoked      bool        `json:"is_revoked"`
	IsApproved     pgtype.Bool `json:"is_approved"`
}

type GetGrantsForGranteeAddressRow struct {
	UserID         trashid.HashId `json:"user_id"`
	GranteeAddress string         `json:"grantee_address"`
	IsRevoked      bool           `json:"is_revoked"`
	IsApproved     pgtype.Bool    `json:"is_approved"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
	GranteeUserID  trashid.HashId `json:"grantee_user_id"`
}

func (q *Queries) GetGrantsForGranteeAddress(ctx context.Context, arg GetGrantsForGranteeAddressParams) ([]GetGrantsForGranteeAddressRow, error) {
	rows, err := q.db.Query(ctx, getGrantsForGranteeAddress, arg.GranteeAddress, arg.IsRevoked, arg.IsApproved)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGrantsForGranteeAddressRow
	for rows.Next() {
		var i GetGrantsForGranteeAddressRow
		if err := rows.Scan(
			&i.UserID,
			&i.GranteeAddress,
			&i.IsRevoked,
			&i.IsApproved,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GranteeUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGrantsForUserId = `-- name: GetGrantsForUserId :many
SELECT
  g.user_id,
  g.grantee_address,
  g.is_revoked,
  g.is_approved,
  g.created_at,
  g.updated_at,
  u.user_id as grantee_user_id
FROM grants g
JOIN users u ON u.wallet = g.grantee_address
WHERE g.user_id = $1::int
  AND g.is_revoked = $2
  AND g.is_current = true
  AND $3::boolean IS NULL OR g.is_approved = $3
ORDER BY g.created_at DESC
`

type GetGrantsForUserIdParams struct {
	UserID     int32       `json:"user_id"`
	IsRevoked  bool        `json:"is_revoked"`
	IsApproved pgtype.Bool `json:"is_approved"`
}

type GetGrantsForUserIdRow struct {
	UserID         trashid.HashId `json:"user_id"`
	GranteeAddress string         `json:"grantee_address"`
	IsRevoked      bool           `json:"is_revoked"`
	IsApproved     pgtype.Bool    `json:"is_approved"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
	GranteeUserID  trashid.HashId `json:"grantee_user_id"`
}

func (q *Queries) GetGrantsForUserId(ctx context.Context, arg GetGrantsForUserIdParams) ([]GetGrantsForUserIdRow, error) {
	rows, err := q.db.Query(ctx, getGrantsForUserId, arg.UserID, arg.IsRevoked, arg.IsApproved)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGrantsForUserIdRow
	for rows.Next() {
		var i GetGrantsForUserIdRow
		if err := rows.Scan(
			&i.UserID,
			&i.GranteeAddress,
			&i.IsRevoked,
			&i.IsApproved,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GranteeUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
