// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: get_grants.sql

package dbv1

import (
	"context"
	"time"

	"bridgerton.audius.co/trashid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getGrantsForGranteeUserId = `-- name: GetGrantsForGranteeUserId :many
SELECT
  g.user_id,
  g.grantee_address,
  g.is_revoked,
  g.is_approved,
  g.created_at,
  g.updated_at,
  u.user_id as grantee_user_id
FROM users u
JOIN grants g ON g.grantee_address = u.wallet
WHERE u.user_id = $1::int
  AND g.is_current = true
  AND g.is_revoked = $2
  AND (g.is_approved = $3 OR $3 IS NULL)
`

type GetGrantsForGranteeUserIdParams struct {
	UserID     int32       `json:"user_id"`
	IsRevoked  bool        `json:"is_revoked"`
	IsApproved pgtype.Bool `json:"is_approved"`
}

type GetGrantsForGranteeUserIdRow struct {
	UserID         trashid.HashId `json:"user_id"`
	GranteeAddress string         `json:"grantee_address"`
	IsRevoked      bool           `json:"is_revoked"`
	IsApproved     pgtype.Bool    `json:"is_approved"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
	GranteeUserID  trashid.HashId `json:"grantee_user_id"`
}

func (q *Queries) GetGrantsForGranteeUserId(ctx context.Context, arg GetGrantsForGranteeUserIdParams) ([]GetGrantsForGranteeUserIdRow, error) {
	rows, err := q.db.Query(ctx, getGrantsForGranteeUserId, arg.UserID, arg.IsRevoked, arg.IsApproved)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGrantsForGranteeUserIdRow
	for rows.Next() {
		var i GetGrantsForGranteeUserIdRow
		if err := rows.Scan(
			&i.UserID,
			&i.GranteeAddress,
			&i.IsRevoked,
			&i.IsApproved,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GranteeUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGrantsForUserId = `-- name: GetGrantsForUserId :many
SELECT
  g.user_id,
  g.grantee_address,
  g.is_revoked,
  g.is_approved,
  g.created_at,
  g.updated_at,
  u.user_id as grantee_user_id
FROM grants g
JOIN users u ON u.wallet = g.grantee_address
WHERE g.user_id = $1::int
  AND g.is_revoked = $2
  AND g.is_current = true
  AND (g.is_approved = $3 OR $3 IS NULL)
`

type GetGrantsForUserIdParams struct {
	UserID     int32       `json:"user_id"`
	IsRevoked  bool        `json:"is_revoked"`
	IsApproved pgtype.Bool `json:"is_approved"`
}

type GetGrantsForUserIdRow struct {
	UserID         trashid.HashId `json:"user_id"`
	GranteeAddress string         `json:"grantee_address"`
	IsRevoked      bool           `json:"is_revoked"`
	IsApproved     pgtype.Bool    `json:"is_approved"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
	GranteeUserID  trashid.HashId `json:"grantee_user_id"`
}

func (q *Queries) GetGrantsForUserId(ctx context.Context, arg GetGrantsForUserIdParams) ([]GetGrantsForUserIdRow, error) {
	rows, err := q.db.Query(ctx, getGrantsForUserId, arg.UserID, arg.IsRevoked, arg.IsApproved)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGrantsForUserIdRow
	for rows.Next() {
		var i GetGrantsForUserIdRow
		if err := rows.Scan(
			&i.UserID,
			&i.GranteeAddress,
			&i.IsRevoked,
			&i.IsApproved,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.GranteeUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
