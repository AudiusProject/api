// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: get_events.sql

package dbv1

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const getEvents = `-- name: GetEvents :many
SELECT
  event_id,
  entity_type::event_entity_type,
  user_id,
  entity_id,
  event_type::event_type,
  end_date,
  is_deleted,
  created_at,
  updated_at,
  event_data
FROM events
WHERE
  ($1::int[] = '{}' OR entity_id = ANY($1::int[]))
  AND ($2::text = '' OR entity_type = $2::event_entity_type)
  AND ($3::text = '' OR event_type = $3::event_type)
  AND ($4::boolean IS NULL OR is_deleted = $4)
ORDER BY created_at DESC, event_id ASC
LIMIT $6
OFFSET $5
`

type GetEventsParams struct {
	EntityIds     []int32 `json:"entity_ids"`
	EntityType    string  `json:"entity_type"`
	EventType     string  `json:"event_type"`
	FilterDeleted bool    `json:"filter_deleted"`
	OffsetVal     int32   `json:"offset_val"`
	LimitVal      int32   `json:"limit_val"`
}

type GetEventsRow struct {
	EventID    int32           `json:"event_id"`
	EntityType EventEntityType `json:"entity_type"`
	UserID     int32           `json:"user_id"`
	EntityID   pgtype.Int4     `json:"entity_id"`
	EventType  EventType       `json:"event_type"`
	EndDate    *time.Time      `json:"end_date"`
	IsDeleted  pgtype.Bool     `json:"is_deleted"`
	CreatedAt  time.Time       `json:"created_at"`
	UpdatedAt  time.Time       `json:"updated_at"`
	EventData  *EventData      `json:"event_data"`
}

func (q *Queries) GetEvents(ctx context.Context, arg GetEventsParams) ([]GetEventsRow, error) {
	rows, err := q.db.Query(ctx, getEvents,
		arg.EntityIds,
		arg.EntityType,
		arg.EventType,
		arg.FilterDeleted,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsRow
	for rows.Next() {
		var i GetEventsRow
		if err := rows.Scan(
			&i.EventID,
			&i.EntityType,
			&i.UserID,
			&i.EntityID,
			&i.EventType,
			&i.EndDate,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EventData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
