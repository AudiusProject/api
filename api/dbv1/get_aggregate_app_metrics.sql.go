// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: get_aggregate_app_metrics.sql

package dbv1

import (
	"context"
)

const getAggregateAppMetrics = `-- name: GetAggregateAppMetrics :many
WITH week_data AS (
    SELECT 
        application_name AS name,
        SUM(count) AS count
    FROM 
        aggregate_daily_app_name_metrics
    WHERE 
        timestamp >= CURRENT_DATE - INTERVAL '7 days'
        AND timestamp < CURRENT_DATE
    GROUP BY 
        application_name
),
month_data AS (
    SELECT 
        application_name AS name,
        SUM(count) AS count
    FROM 
        aggregate_daily_app_name_metrics
    WHERE 
        timestamp >= CURRENT_DATE - INTERVAL '30 days'
        AND timestamp < CURRENT_DATE
    GROUP BY 
        application_name
),
year_data AS (
    SELECT 
        application_name AS name,
        SUM(count) AS count
    FROM 
        aggregate_monthly_app_name_metrics
    WHERE 
        timestamp >= CURRENT_DATE - INTERVAL '365 days'
        AND timestamp < CURRENT_DATE
    GROUP BY 
        application_name
),
all_time_data AS (
    SELECT 
        application_name AS name,
        SUM(count) AS count
    FROM 
        aggregate_monthly_app_name_metrics
    WHERE 
        timestamp < CURRENT_DATE
    GROUP BY 
        application_name
),
time_range_data AS (
    SELECT name, count FROM week_data WHERE $2 = 'week'
    UNION ALL
    SELECT name, count FROM month_data WHERE $2 = 'month'
    UNION ALL
    SELECT name, count FROM year_data WHERE $2 = 'year'
    UNION ALL
    SELECT name, count FROM all_time_data WHERE $2 = 'all_time'
)
SELECT
    name,
    count
FROM
    time_range_data
ORDER BY
    count DESC,
    name ASC
LIMIT $1
`

type GetAggregateAppMetricsParams struct {
	LimitVal  int32       `json:"limit_val"`
	TimeRange interface{} `json:"time_range"`
}

type GetAggregateAppMetricsRow struct {
	Name  string `json:"name"`
	Count int64  `json:"count"`
}

func (q *Queries) GetAggregateAppMetrics(ctx context.Context, arg GetAggregateAppMetricsParams) ([]GetAggregateAppMetricsRow, error) {
	rows, err := q.db.Query(ctx, getAggregateAppMetrics, arg.LimitVal, arg.TimeRange)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAggregateAppMetricsRow
	for rows.Next() {
		var i GetAggregateAppMetricsRow
		if err := rows.Scan(&i.Name, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
