// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: get_playlists.sql

package dbv1

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getPlaylists = `-- name: GetPlaylists :many
SELECT
  p.playlist_id,
  p.playlist_name,
  p.playlist_owner_id,
  p.playlist_contents,

  (
    SELECT count(*) > 0
    FROM reposts
    WHERE $1 > 0
      AND user_id = $1
      AND repost_type != 'track'
      AND repost_item_id = p.playlist_id
      AND is_delete = false
  ) AS has_current_user_reposted,

  (
    SELECT count(*) > 0
    FROM saves
    WHERE $1 > 0
      AND user_id = $1
      AND save_type != 'track'
      AND save_item_id = p.playlist_id
      AND is_delete = false
  ) AS has_current_user_saved

FROM playlists p
WHERE is_delete = false
  and playlist_id = ANY($2::int[])
`

type GetPlaylistsParams struct {
	MyID interface{} `json:"my_id"`
	Ids  []int32     `json:"ids"`
}

type GetPlaylistsRow struct {
	PlaylistID             int32            `json:"playlist_id"`
	PlaylistName           pgtype.Text      `json:"playlist_name"`
	PlaylistOwnerID        int32            `json:"playlist_owner_id"`
	PlaylistContents       PlaylistContents `json:"playlist_contents"`
	HasCurrentUserReposted bool             `json:"has_current_user_reposted"`
	HasCurrentUserSaved    bool             `json:"has_current_user_saved"`
}

func (q *Queries) GetPlaylists(ctx context.Context, arg GetPlaylistsParams) ([]GetPlaylistsRow, error) {
	rows, err := q.db.Query(ctx, getPlaylists, arg.MyID, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaylistsRow
	for rows.Next() {
		var i GetPlaylistsRow
		if err := rows.Scan(
			&i.PlaylistID,
			&i.PlaylistName,
			&i.PlaylistOwnerID,
			&i.PlaylistContents,
			&i.HasCurrentUserReposted,
			&i.HasCurrentUserSaved,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
