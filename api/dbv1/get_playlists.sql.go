// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: get_playlists.sql

package dbv1

import (
	"context"
	"encoding/json"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const getPlaylists = `-- name: GetPlaylists :many
SELECT
  -- artwork
  p.description,
  -- permalink
  -- id
  p.is_album,
  p.is_delete,
  p.is_image_autogenerated,
  p.is_private,
  p.is_scheduled_release,
  p.is_stream_gated,
  p.stream_conditions,
  -- is_streamable,

  coalesce(playlist_image_sizes_multihash, playlist_image_multihash) as artwork,

  p.playlist_name,

  p.playlist_id,
  p.playlist_owner_id,
  p.playlist_contents,

  p.blocknumber,

  repost_count,
  save_count as favorite_count,
  created_at,
  updated_at,
  release_date,

  (
    SELECT count(*) > 0
    FROM reposts
    WHERE $1 > 0
      AND user_id = $1
      AND repost_type != 'track'
      AND repost_item_id = p.playlist_id
      AND is_delete = false
  ) AS has_current_user_reposted,

  (
    SELECT count(*) > 0
    FROM saves
    WHERE $1 > 0
      AND user_id = $1
      AND save_type != 'track'
      AND save_item_id = p.playlist_id
      AND is_delete = false
  ) AS has_current_user_saved,


  (
    SELECT json_agg(
      json_build_object(
        'user_id', r.user_id::text,
        'repost_item_id', repost_item_id::text, -- this is redundant
        'repost_type', 'RepostType.track', -- some sqlalchemy bs
        'created_at', r.created_at -- this is not actually present in python response?
      )
    )
    FROM (
      SELECT user_id, repost_item_id, reposts.created_at
      FROM reposts
      JOIN follows ON followee_user_id = reposts.user_id AND follower_user_id = $1
      JOIN aggregate_user USING (user_id)
      WHERE repost_item_id = p.playlist_id
        AND repost_type != 'track'
        AND reposts.is_delete = false
      ORDER BY follower_count DESC
      LIMIT 6
    ) r
  )::jsonb as followee_reposts,

  (
    SELECT json_agg(
      json_build_object(
        'user_id', r.user_id::text,
        'favorite_item_id', r.save_item_id::text, -- this is redundant
        'favorite_type', 'SaveType.track', -- some sqlalchemy bs
        'created_at', r.created_at -- this is not actually present in python response?
      )
    )
    FROM (
      SELECT user_id, save_item_id, saves.created_at
      FROM saves
      JOIN follows ON followee_user_id = saves.user_id AND follower_user_id = $1
      JOIN aggregate_user USING (user_id)
      WHERE save_item_id = p.playlist_id
        AND save_type != 'track'
        AND saves.is_delete = false
      ORDER BY follower_count DESC
      LIMIT 6
    ) r
  )::jsonb as followee_favorites

FROM playlists p
JOIN aggregate_playlist using (playlist_id)
WHERE is_delete = false
  and playlist_id = ANY($2::int[])
`

type GetPlaylistsParams struct {
	MyID interface{} `json:"my_id"`
	Ids  []int32     `json:"ids"`
}

type GetPlaylistsRow struct {
	Description            pgtype.Text      `json:"description"`
	IsAlbum                bool             `json:"is_album"`
	IsDelete               bool             `json:"is_delete"`
	IsImageAutogenerated   bool             `json:"is_image_autogenerated"`
	IsPrivate              bool             `json:"is_private"`
	IsScheduledRelease     bool             `json:"is_scheduled_release"`
	IsStreamGated          pgtype.Bool      `json:"is_stream_gated"`
	StreamConditions       *AccessGate      `json:"stream_conditions"`
	Artwork                pgtype.Text      `json:"artwork"`
	PlaylistName           pgtype.Text      `json:"playlist_name"`
	PlaylistID             int32            `json:"playlist_id"`
	PlaylistOwnerID        int32            `json:"playlist_owner_id"`
	PlaylistContents       PlaylistContents `json:"playlist_contents"`
	Blocknumber            pgtype.Int4      `json:"blocknumber"`
	RepostCount            pgtype.Int4      `json:"repost_count"`
	FavoriteCount          pgtype.Int4      `json:"favorite_count"`
	CreatedAt              time.Time        `json:"created_at"`
	UpdatedAt              time.Time        `json:"updated_at"`
	ReleaseDate            *time.Time       `json:"release_date"`
	HasCurrentUserReposted bool             `json:"has_current_user_reposted"`
	HasCurrentUserSaved    bool             `json:"has_current_user_saved"`
	FolloweeReposts        json.RawMessage  `json:"followee_reposts"`
	FolloweeFavorites      json.RawMessage  `json:"followee_favorites"`
}

func (q *Queries) GetPlaylists(ctx context.Context, arg GetPlaylistsParams) ([]GetPlaylistsRow, error) {
	rows, err := q.db.Query(ctx, getPlaylists, arg.MyID, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaylistsRow
	for rows.Next() {
		var i GetPlaylistsRow
		if err := rows.Scan(
			&i.Description,
			&i.IsAlbum,
			&i.IsDelete,
			&i.IsImageAutogenerated,
			&i.IsPrivate,
			&i.IsScheduledRelease,
			&i.IsStreamGated,
			&i.StreamConditions,
			&i.Artwork,
			&i.PlaylistName,
			&i.PlaylistID,
			&i.PlaylistOwnerID,
			&i.PlaylistContents,
			&i.Blocknumber,
			&i.RepostCount,
			&i.FavoriteCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.HasCurrentUserReposted,
			&i.HasCurrentUserSaved,
			&i.FolloweeReposts,
			&i.FolloweeFavorites,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
