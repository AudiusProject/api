// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: get_playlists.sql

package dbv1

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getPlaylists = `-- name: GetPlaylists :many
SELECT
  -- artwork
  p.description,
  -- permalink
  -- id
  p.is_album,
  p.is_delete,
  p.is_image_autogenerated,
  p.is_private,
  p.is_scheduled_release,
  p.is_stream_gated,
  -- is_streamable,

  p.playlist_name,

  p.playlist_id,
  p.playlist_owner_id,
  p.playlist_contents,

  p.blocknumber,

  repost_count,
  save_count as favorite_count,
  created_at,
  updated_at,
  release_date,

  (
    SELECT count(*) > 0
    FROM reposts
    WHERE $1 > 0
      AND user_id = $1
      AND repost_type != 'track'
      AND repost_item_id = p.playlist_id
      AND is_delete = false
  ) AS has_current_user_reposted,

  (
    SELECT count(*) > 0
    FROM saves
    WHERE $1 > 0
      AND user_id = $1
      AND save_type != 'track'
      AND save_item_id = p.playlist_id
      AND is_delete = false
  ) AS has_current_user_saved

FROM playlists p
JOIN aggregate_playlist using (playlist_id)
WHERE is_delete = false
  and playlist_id = ANY($2::int[])
`

type GetPlaylistsParams struct {
	MyID interface{} `json:"my_id"`
	Ids  []int32     `json:"ids"`
}

type GetPlaylistsRow struct {
	Description            pgtype.Text      `json:"description"`
	IsAlbum                bool             `json:"is_album"`
	IsDelete               bool             `json:"is_delete"`
	IsImageAutogenerated   bool             `json:"is_image_autogenerated"`
	IsPrivate              bool             `json:"is_private"`
	IsScheduledRelease     bool             `json:"is_scheduled_release"`
	IsStreamGated          pgtype.Bool      `json:"is_stream_gated"`
	PlaylistName           pgtype.Text      `json:"playlist_name"`
	PlaylistID             int32            `json:"playlist_id"`
	PlaylistOwnerID        int32            `json:"playlist_owner_id"`
	PlaylistContents       PlaylistContents `json:"playlist_contents"`
	Blocknumber            pgtype.Int4      `json:"blocknumber"`
	RepostCount            pgtype.Int4      `json:"repost_count"`
	FavoriteCount          pgtype.Int4      `json:"favorite_count"`
	CreatedAt              pgtype.Timestamp `json:"created_at"`
	UpdatedAt              pgtype.Timestamp `json:"updated_at"`
	ReleaseDate            pgtype.Timestamp `json:"release_date"`
	HasCurrentUserReposted bool             `json:"has_current_user_reposted"`
	HasCurrentUserSaved    bool             `json:"has_current_user_saved"`
}

func (q *Queries) GetPlaylists(ctx context.Context, arg GetPlaylistsParams) ([]GetPlaylistsRow, error) {
	rows, err := q.db.Query(ctx, getPlaylists, arg.MyID, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaylistsRow
	for rows.Next() {
		var i GetPlaylistsRow
		if err := rows.Scan(
			&i.Description,
			&i.IsAlbum,
			&i.IsDelete,
			&i.IsImageAutogenerated,
			&i.IsPrivate,
			&i.IsScheduledRelease,
			&i.IsStreamGated,
			&i.PlaylistName,
			&i.PlaylistID,
			&i.PlaylistOwnerID,
			&i.PlaylistContents,
			&i.Blocknumber,
			&i.RepostCount,
			&i.FavoriteCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReleaseDate,
			&i.HasCurrentUserReposted,
			&i.HasCurrentUserSaved,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
