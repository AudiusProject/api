// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package dbv1

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"

	"bridgerton.audius.co/trashid"
	"github.com/jackc/pgx/v5/pgtype"
)

type Challengetype string

const (
	ChallengetypeBoolean   Challengetype = "boolean"
	ChallengetypeNumeric   Challengetype = "numeric"
	ChallengetypeAggregate Challengetype = "aggregate"
	ChallengetypeTrending  Challengetype = "trending"
)

func (e *Challengetype) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Challengetype(s)
	case string:
		*e = Challengetype(s)
	default:
		return fmt.Errorf("unsupported scan type for Challengetype: %T", src)
	}
	return nil
}

type NullChallengetype struct {
	Challengetype Challengetype `json:"challengetype"`
	Valid         bool          `json:"valid"` // Valid is true if Challengetype is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullChallengetype) Scan(value interface{}) error {
	if value == nil {
		ns.Challengetype, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Challengetype.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullChallengetype) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Challengetype), nil
}

type DelistEntity string

const (
	DelistEntityTRACKS DelistEntity = "TRACKS"
	DelistEntityUSERS  DelistEntity = "USERS"
)

func (e *DelistEntity) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DelistEntity(s)
	case string:
		*e = DelistEntity(s)
	default:
		return fmt.Errorf("unsupported scan type for DelistEntity: %T", src)
	}
	return nil
}

type NullDelistEntity struct {
	DelistEntity DelistEntity `json:"delist_entity"`
	Valid        bool         `json:"valid"` // Valid is true if DelistEntity is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDelistEntity) Scan(value interface{}) error {
	if value == nil {
		ns.DelistEntity, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DelistEntity.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDelistEntity) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DelistEntity), nil
}

type DelistTrackReason string

const (
	DelistTrackReasonDMCA                    DelistTrackReason = "DMCA"
	DelistTrackReasonACR                     DelistTrackReason = "ACR"
	DelistTrackReasonMANUAL                  DelistTrackReason = "MANUAL"
	DelistTrackReasonACRCOUNTERNOTICE        DelistTrackReason = "ACR_COUNTER_NOTICE"
	DelistTrackReasonDMCARETRACTION          DelistTrackReason = "DMCA_RETRACTION"
	DelistTrackReasonDMCACOUNTERNOTICE       DelistTrackReason = "DMCA_COUNTER_NOTICE"
	DelistTrackReasonDMCAANDACRCOUNTERNOTICE DelistTrackReason = "DMCA_AND_ACR_COUNTER_NOTICE"
)

func (e *DelistTrackReason) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DelistTrackReason(s)
	case string:
		*e = DelistTrackReason(s)
	default:
		return fmt.Errorf("unsupported scan type for DelistTrackReason: %T", src)
	}
	return nil
}

type NullDelistTrackReason struct {
	DelistTrackReason DelistTrackReason `json:"delist_track_reason"`
	Valid             bool              `json:"valid"` // Valid is true if DelistTrackReason is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDelistTrackReason) Scan(value interface{}) error {
	if value == nil {
		ns.DelistTrackReason, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DelistTrackReason.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDelistTrackReason) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DelistTrackReason), nil
}

type DelistUserReason string

const (
	DelistUserReasonSTRIKETHRESHOLD DelistUserReason = "STRIKE_THRESHOLD"
	DelistUserReasonCOPYRIGHTSCHOOL DelistUserReason = "COPYRIGHT_SCHOOL"
	DelistUserReasonMANUAL          DelistUserReason = "MANUAL"
)

func (e *DelistUserReason) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DelistUserReason(s)
	case string:
		*e = DelistUserReason(s)
	default:
		return fmt.Errorf("unsupported scan type for DelistUserReason: %T", src)
	}
	return nil
}

type NullDelistUserReason struct {
	DelistUserReason DelistUserReason `json:"delist_user_reason"`
	Valid            bool             `json:"valid"` // Valid is true if DelistUserReason is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDelistUserReason) Scan(value interface{}) error {
	if value == nil {
		ns.DelistUserReason, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DelistUserReason.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDelistUserReason) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DelistUserReason), nil
}

type EventEntityType string

const (
	EventEntityTypeTrack      EventEntityType = "track"
	EventEntityTypeCollection EventEntityType = "collection"
	EventEntityTypeUser       EventEntityType = "user"
)

func (e *EventEntityType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EventEntityType(s)
	case string:
		*e = EventEntityType(s)
	default:
		return fmt.Errorf("unsupported scan type for EventEntityType: %T", src)
	}
	return nil
}

type NullEventEntityType struct {
	EventEntityType EventEntityType `json:"event_entity_type"`
	Valid           bool            `json:"valid"` // Valid is true if EventEntityType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEventEntityType) Scan(value interface{}) error {
	if value == nil {
		ns.EventEntityType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EventEntityType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEventEntityType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EventEntityType), nil
}

type EventType string

const (
	EventTypeRemixContest EventType = "remix_contest"
	EventTypeLiveEvent    EventType = "live_event"
	EventTypeNewRelease   EventType = "new_release"
)

func (e *EventType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EventType(s)
	case string:
		*e = EventType(s)
	default:
		return fmt.Errorf("unsupported scan type for EventType: %T", src)
	}
	return nil
}

type NullEventType struct {
	EventType EventType `json:"event_type"`
	Valid     bool      `json:"valid"` // Valid is true if EventType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEventType) Scan(value interface{}) error {
	if value == nil {
		ns.EventType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EventType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEventType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EventType), nil
}

type ParentalWarningType string

const (
	ParentalWarningTypeExplicit              ParentalWarningType = "explicit"
	ParentalWarningTypeExplicitContentEdited ParentalWarningType = "explicit_content_edited"
	ParentalWarningTypeNotExplicit           ParentalWarningType = "not_explicit"
	ParentalWarningTypeNoAdviceAvailable     ParentalWarningType = "no_advice_available"
)

func (e *ParentalWarningType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ParentalWarningType(s)
	case string:
		*e = ParentalWarningType(s)
	default:
		return fmt.Errorf("unsupported scan type for ParentalWarningType: %T", src)
	}
	return nil
}

type NullParentalWarningType struct {
	ParentalWarningType ParentalWarningType `json:"parental_warning_type"`
	Valid               bool                `json:"valid"` // Valid is true if ParentalWarningType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullParentalWarningType) Scan(value interface{}) error {
	if value == nil {
		ns.ParentalWarningType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ParentalWarningType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullParentalWarningType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ParentalWarningType), nil
}

type ProfileTypeEnum string

const (
	ProfileTypeEnumLabel ProfileTypeEnum = "label"
)

func (e *ProfileTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProfileTypeEnum(s)
	case string:
		*e = ProfileTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for ProfileTypeEnum: %T", src)
	}
	return nil
}

type NullProfileTypeEnum struct {
	ProfileTypeEnum ProfileTypeEnum `json:"profile_type_enum"`
	Valid           bool            `json:"valid"` // Valid is true if ProfileTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProfileTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.ProfileTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProfileTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProfileTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProfileTypeEnum), nil
}

type ProofStatus string

const (
	ProofStatusUnresolved ProofStatus = "unresolved"
	ProofStatusPass       ProofStatus = "pass"
	ProofStatusFail       ProofStatus = "fail"
)

func (e *ProofStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProofStatus(s)
	case string:
		*e = ProofStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ProofStatus: %T", src)
	}
	return nil
}

type NullProofStatus struct {
	ProofStatus ProofStatus `json:"proof_status"`
	Valid       bool        `json:"valid"` // Valid is true if ProofStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProofStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ProofStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProofStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProofStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProofStatus), nil
}

type Reposttype string

const (
	ReposttypeTrack    Reposttype = "track"
	ReposttypePlaylist Reposttype = "playlist"
	ReposttypeAlbum    Reposttype = "album"
)

func (e *Reposttype) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Reposttype(s)
	case string:
		*e = Reposttype(s)
	default:
		return fmt.Errorf("unsupported scan type for Reposttype: %T", src)
	}
	return nil
}

type NullReposttype struct {
	Reposttype Reposttype `json:"reposttype"`
	Valid      bool       `json:"valid"` // Valid is true if Reposttype is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullReposttype) Scan(value interface{}) error {
	if value == nil {
		ns.Reposttype, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Reposttype.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullReposttype) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Reposttype), nil
}

type Savetype string

const (
	SavetypeTrack    Savetype = "track"
	SavetypePlaylist Savetype = "playlist"
	SavetypeAlbum    Savetype = "album"
)

func (e *Savetype) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Savetype(s)
	case string:
		*e = Savetype(s)
	default:
		return fmt.Errorf("unsupported scan type for Savetype: %T", src)
	}
	return nil
}

type NullSavetype struct {
	Savetype Savetype `json:"savetype"`
	Valid    bool     `json:"valid"` // Valid is true if Savetype is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSavetype) Scan(value interface{}) error {
	if value == nil {
		ns.Savetype, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Savetype.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSavetype) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Savetype), nil
}

type Sharetype string

const (
	SharetypeTrack    Sharetype = "track"
	SharetypePlaylist Sharetype = "playlist"
)

func (e *Sharetype) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Sharetype(s)
	case string:
		*e = Sharetype(s)
	default:
		return fmt.Errorf("unsupported scan type for Sharetype: %T", src)
	}
	return nil
}

type NullSharetype struct {
	Sharetype Sharetype `json:"sharetype"`
	Valid     bool      `json:"valid"` // Valid is true if Sharetype is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSharetype) Scan(value interface{}) error {
	if value == nil {
		ns.Sharetype, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Sharetype.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSharetype) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Sharetype), nil
}

type Skippedtransactionlevel string

const (
	SkippedtransactionlevelNode    Skippedtransactionlevel = "node"
	SkippedtransactionlevelNetwork Skippedtransactionlevel = "network"
)

func (e *Skippedtransactionlevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Skippedtransactionlevel(s)
	case string:
		*e = Skippedtransactionlevel(s)
	default:
		return fmt.Errorf("unsupported scan type for Skippedtransactionlevel: %T", src)
	}
	return nil
}

type NullSkippedtransactionlevel struct {
	Skippedtransactionlevel Skippedtransactionlevel `json:"skippedtransactionlevel"`
	Valid                   bool                    `json:"valid"` // Valid is true if Skippedtransactionlevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSkippedtransactionlevel) Scan(value interface{}) error {
	if value == nil {
		ns.Skippedtransactionlevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Skippedtransactionlevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSkippedtransactionlevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Skippedtransactionlevel), nil
}

type UsdcPurchaseAccessType string

const (
	UsdcPurchaseAccessTypeStream   UsdcPurchaseAccessType = "stream"
	UsdcPurchaseAccessTypeDownload UsdcPurchaseAccessType = "download"
)

func (e *UsdcPurchaseAccessType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UsdcPurchaseAccessType(s)
	case string:
		*e = UsdcPurchaseAccessType(s)
	default:
		return fmt.Errorf("unsupported scan type for UsdcPurchaseAccessType: %T", src)
	}
	return nil
}

type NullUsdcPurchaseAccessType struct {
	UsdcPurchaseAccessType UsdcPurchaseAccessType `json:"usdc_purchase_access_type"`
	Valid                  bool                   `json:"valid"` // Valid is true if UsdcPurchaseAccessType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUsdcPurchaseAccessType) Scan(value interface{}) error {
	if value == nil {
		ns.UsdcPurchaseAccessType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UsdcPurchaseAccessType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUsdcPurchaseAccessType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UsdcPurchaseAccessType), nil
}

type UsdcPurchaseContentType string

const (
	UsdcPurchaseContentTypeTrack    UsdcPurchaseContentType = "track"
	UsdcPurchaseContentTypePlaylist UsdcPurchaseContentType = "playlist"
	UsdcPurchaseContentTypeAlbum    UsdcPurchaseContentType = "album"
)

func (e *UsdcPurchaseContentType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UsdcPurchaseContentType(s)
	case string:
		*e = UsdcPurchaseContentType(s)
	default:
		return fmt.Errorf("unsupported scan type for UsdcPurchaseContentType: %T", src)
	}
	return nil
}

type NullUsdcPurchaseContentType struct {
	UsdcPurchaseContentType UsdcPurchaseContentType `json:"usdc_purchase_content_type"`
	Valid                   bool                    `json:"valid"` // Valid is true if UsdcPurchaseContentType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUsdcPurchaseContentType) Scan(value interface{}) error {
	if value == nil {
		ns.UsdcPurchaseContentType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UsdcPurchaseContentType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUsdcPurchaseContentType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UsdcPurchaseContentType), nil
}

type ValidatorEvent string

const (
	ValidatorEventRegistered   ValidatorEvent = "registered"
	ValidatorEventDeregistered ValidatorEvent = "deregistered"
)

func (e *ValidatorEvent) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ValidatorEvent(s)
	case string:
		*e = ValidatorEvent(s)
	default:
		return fmt.Errorf("unsupported scan type for ValidatorEvent: %T", src)
	}
	return nil
}

type NullValidatorEvent struct {
	ValidatorEvent ValidatorEvent `json:"validator_event"`
	Valid          bool           `json:"valid"` // Valid is true if ValidatorEvent is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullValidatorEvent) Scan(value interface{}) error {
	if value == nil {
		ns.ValidatorEvent, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ValidatorEvent.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullValidatorEvent) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ValidatorEvent), nil
}

type WalletChain string

const (
	WalletChainEth WalletChain = "eth"
	WalletChainSol WalletChain = "sol"
)

func (e *WalletChain) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WalletChain(s)
	case string:
		*e = WalletChain(s)
	default:
		return fmt.Errorf("unsupported scan type for WalletChain: %T", src)
	}
	return nil
}

type NullWalletChain struct {
	WalletChain WalletChain `json:"wallet_chain"`
	Valid       bool        `json:"valid"` // Valid is true if WalletChain is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWalletChain) Scan(value interface{}) error {
	if value == nil {
		ns.WalletChain, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WalletChain.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWalletChain) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WalletChain), nil
}

type AccessKey struct {
	ID      int32  `json:"id"`
	TrackID string `json:"track_id"`
	PubKey  string `json:"pub_key"`
}

type AggregateDailyAppNameMetric struct {
	ID              int32       `json:"id"`
	ApplicationName string      `json:"application_name"`
	Count           int32       `json:"count"`
	Timestamp       pgtype.Date `json:"timestamp"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
}

type AggregateDailyTotalUsersMetric struct {
	ID            int32       `json:"id"`
	Count         int32       `json:"count"`
	Timestamp     pgtype.Date `json:"timestamp"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	PersonalCount pgtype.Int4 `json:"personal_count"`
}

type AggregateDailyUniqueUsersMetric struct {
	ID            int32       `json:"id"`
	Count         int32       `json:"count"`
	Timestamp     pgtype.Date `json:"timestamp"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	SummedCount   pgtype.Int4 `json:"summed_count"`
	PersonalCount pgtype.Int4 `json:"personal_count"`
}

type AggregateIntervalPlay struct {
	TrackID           int32       `json:"track_id"`
	Genre             pgtype.Text `json:"genre"`
	CreatedAt         time.Time   `json:"created_at"`
	WeekListenCounts  int64       `json:"week_listen_counts"`
	MonthListenCounts int64       `json:"month_listen_counts"`
}

type AggregateMonthlyAppNameMetric struct {
	ID              int32       `json:"id"`
	ApplicationName string      `json:"application_name"`
	Count           int32       `json:"count"`
	Timestamp       pgtype.Date `json:"timestamp"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
}

type AggregateMonthlyPlay struct {
	PlayItemID int32       `json:"play_item_id"`
	Timestamp  pgtype.Date `json:"timestamp"`
	Count      int32       `json:"count"`
	Country    string      `json:"country"`
}

type AggregateMonthlyTotalUsersMetric struct {
	ID            int32       `json:"id"`
	Count         int32       `json:"count"`
	Timestamp     pgtype.Date `json:"timestamp"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	PersonalCount pgtype.Int4 `json:"personal_count"`
}

type AggregateMonthlyUniqueUsersMetric struct {
	ID            int32       `json:"id"`
	Count         int32       `json:"count"`
	Timestamp     pgtype.Date `json:"timestamp"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	SummedCount   pgtype.Int4 `json:"summed_count"`
	PersonalCount pgtype.Int4 `json:"personal_count"`
}

type AggregatePlay struct {
	PlayItemID int32       `json:"play_item_id"`
	Count      pgtype.Int8 `json:"count"`
}

type AggregatePlaylist struct {
	PlaylistID  int32       `json:"playlist_id"`
	IsAlbum     pgtype.Bool `json:"is_album"`
	RepostCount pgtype.Int4 `json:"repost_count"`
	SaveCount   pgtype.Int4 `json:"save_count"`
	ShareCount  pgtype.Int4 `json:"share_count"`
}

type AggregateTrack struct {
	TrackID      int32       `json:"track_id"`
	RepostCount  int32       `json:"repost_count"`
	SaveCount    int32       `json:"save_count"`
	CommentCount pgtype.Int4 `json:"comment_count"`
	ShareCount   pgtype.Int4 `json:"share_count"`
}

type AggregateUser struct {
	UserID             int32       `json:"user_id"`
	TrackCount         pgtype.Int8 `json:"track_count"`
	PlaylistCount      pgtype.Int8 `json:"playlist_count"`
	AlbumCount         pgtype.Int8 `json:"album_count"`
	FollowerCount      pgtype.Int8 `json:"follower_count"`
	FollowingCount     pgtype.Int8 `json:"following_count"`
	RepostCount        pgtype.Int8 `json:"repost_count"`
	TrackSaveCount     pgtype.Int8 `json:"track_save_count"`
	SupporterCount     int32       `json:"supporter_count"`
	SupportingCount    int32       `json:"supporting_count"`
	DominantGenre      pgtype.Text `json:"dominant_genre"`
	DominantGenreCount pgtype.Int4 `json:"dominant_genre_count"`
	Score              pgtype.Int4 `json:"score"`
	TotalTrackCount    pgtype.Int8 `json:"total_track_count"`
	TrackShareCount    pgtype.Int4 `json:"track_share_count"`
}

type AggregateUserTip struct {
	SenderUserID   int32 `json:"sender_user_id"`
	ReceiverUserID int32 `json:"receiver_user_id"`
	Amount         int64 `json:"amount"`
}

type AlbumPriceHistory struct {
	PlaylistID      int32           `json:"playlist_id"`
	Splits          json.RawMessage `json:"splits"`
	TotalPriceCents int64           `json:"total_price_cents"`
	Blocknumber     int32           `json:"blocknumber"`
	BlockTimestamp  time.Time       `json:"block_timestamp"`
	CreatedAt       time.Time       `json:"created_at"`
}

type AlembicVersion struct {
	VersionNum string `json:"version_num"`
}

type AntiAbuseBlockedUser struct {
	HandleLc  string     `json:"handle_lc"`
	IsBlocked bool       `json:"is_blocked"`
	CreatedAt *time.Time `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
}

type ApiMetricsApp struct {
	Date         pgtype.Date `json:"date"`
	ApiKey       string      `json:"api_key"`
	AppName      string      `json:"app_name"`
	RequestCount int64       `json:"request_count"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
}

type ApiMetricsCount struct {
	Date        pgtype.Date `json:"date"`
	HllSketch   []byte      `json:"hll_sketch"`
	TotalCount  int64       `json:"total_count"`
	UniqueCount int64       `json:"unique_count"`
	CreatedAt   *time.Time  `json:"created_at"`
	UpdatedAt   *time.Time  `json:"updated_at"`
}

type ApiMetricsRoute struct {
	Date         pgtype.Date `json:"date"`
	RoutePattern string      `json:"route_pattern"`
	Method       string      `json:"method"`
	RequestCount int64       `json:"request_count"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
}

type AppNameMetric struct {
	ApplicationName string      `json:"application_name"`
	Count           int32       `json:"count"`
	Timestamp       time.Time   `json:"timestamp"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	ID              int64       `json:"id"`
	Ip              pgtype.Text `json:"ip"`
}

type AppNameMetricsAllTime struct {
	Name  string `json:"name"`
	Count int64  `json:"count"`
}

type AppNameMetricsTrailingMonth struct {
	Name  string `json:"name"`
	Count int64  `json:"count"`
}

type AppNameMetricsTrailingWeek struct {
	Name  string `json:"name"`
	Count int64  `json:"count"`
}

// Stores the token mints for artist coins that the indexer is tracking and their tickers.
type ArtistCoin struct {
	Mint        string      `json:"mint"`
	Ticker      string      `json:"ticker"`
	UserID      int32       `json:"user_id"`
	Decimals    int32       `json:"decimals"`
	CreatedAt   time.Time   `json:"created_at"`
	LogoUri     pgtype.Text `json:"logo_uri"`
	Description pgtype.Text `json:"description"`
	Website     pgtype.Text `json:"website"`
	Name        string      `json:"name"`
	DbcPool     pgtype.Text `json:"dbc_pool"`
}

type ArtistCoinPool struct {
	Address                 string         `json:"address"`
	BaseMint                string         `json:"base_mint"`
	QuoteMint               pgtype.Text    `json:"quote_mint"`
	TokenDecimals           pgtype.Int4    `json:"token_decimals"`
	BaseReserve             pgtype.Numeric `json:"base_reserve"`
	QuoteReserve            pgtype.Numeric `json:"quote_reserve"`
	MigrationBaseThreshold  pgtype.Numeric `json:"migration_base_threshold"`
	MigrationQuoteThreshold pgtype.Numeric `json:"migration_quote_threshold"`
	ProtocolQuoteFee        pgtype.Numeric `json:"protocol_quote_fee"`
	PartnerQuoteFee         pgtype.Numeric `json:"partner_quote_fee"`
	CreatorBaseFee          pgtype.Numeric `json:"creator_base_fee"`
	CreatorQuoteFee         pgtype.Numeric `json:"creator_quote_fee"`
	Price                   pgtype.Float8  `json:"price"`
	PriceUsd                pgtype.Float8  `json:"price_usd"`
	CurveProgress           pgtype.Float8  `json:"curve_progress"`
	IsMigrated              pgtype.Bool    `json:"is_migrated"`
	CreatedAt               time.Time      `json:"created_at"`
	UpdatedAt               time.Time      `json:"updated_at"`
}

type ArtistCoinStat struct {
	Mint                         string        `json:"mint"`
	MarketCap                    pgtype.Float8 `json:"market_cap"`
	Fdv                          pgtype.Float8 `json:"fdv"`
	Liquidity                    pgtype.Float8 `json:"liquidity"`
	LastTradeUnixTime            pgtype.Int8   `json:"last_trade_unix_time"`
	LastTradeHumanTime           pgtype.Text   `json:"last_trade_human_time"`
	Price                        pgtype.Float8 `json:"price"`
	History24hPrice              pgtype.Float8 `json:"history_24h_price"`
	PriceChange24hPercent        pgtype.Float8 `json:"price_change_24h_percent"`
	UniqueWallet24h              pgtype.Int4   `json:"unique_wallet_24h"`
	UniqueWalletHistory24h       pgtype.Int4   `json:"unique_wallet_history_24h"`
	UniqueWallet24hChangePercent pgtype.Float8 `json:"unique_wallet_24h_change_percent"`
	TotalSupply                  pgtype.Float8 `json:"total_supply"`
	CirculatingSupply            pgtype.Float8 `json:"circulating_supply"`
	Holder                       pgtype.Int4   `json:"holder"`
	Trade24h                     pgtype.Int4   `json:"trade_24h"`
	TradeHistory24h              pgtype.Int4   `json:"trade_history_24h"`
	Trade24hChangePercent        pgtype.Float8 `json:"trade_24h_change_percent"`
	Sell24h                      pgtype.Int4   `json:"sell_24h"`
	SellHistory24h               pgtype.Int4   `json:"sell_history_24h"`
	Sell24hChangePercent         pgtype.Float8 `json:"sell_24h_change_percent"`
	Buy24h                       pgtype.Int4   `json:"buy_24h"`
	BuyHistory24h                pgtype.Int4   `json:"buy_history_24h"`
	Buy24hChangePercent          pgtype.Float8 `json:"buy_24h_change_percent"`
	V24h                         pgtype.Float8 `json:"v_24h"`
	V24hUsd                      pgtype.Float8 `json:"v_24h_usd"`
	VHistory24h                  pgtype.Float8 `json:"v_history_24h"`
	VHistory24hUsd               pgtype.Float8 `json:"v_history_24h_usd"`
	V24hChangePercent            pgtype.Float8 `json:"v_24h_change_percent"`
	VBuy24h                      pgtype.Float8 `json:"v_buy_24h"`
	VBuy24hUsd                   pgtype.Float8 `json:"v_buy_24h_usd"`
	VBuyHistory24h               pgtype.Float8 `json:"v_buy_history_24h"`
	VBuyHistory24hUsd            pgtype.Float8 `json:"v_buy_history_24h_usd"`
	VBuy24hChangePercent         pgtype.Float8 `json:"v_buy_24h_change_percent"`
	VSell24h                     pgtype.Float8 `json:"v_sell_24h"`
	VSell24hUsd                  pgtype.Float8 `json:"v_sell_24h_usd"`
	VSellHistory24h              pgtype.Float8 `json:"v_sell_history_24h"`
	VSellHistory24hUsd           pgtype.Float8 `json:"v_sell_history_24h_usd"`
	VSell24hChangePercent        pgtype.Float8 `json:"v_sell_24h_change_percent"`
	NumberMarkets                pgtype.Int4   `json:"number_markets"`
	CreatedAt                    time.Time     `json:"created_at"`
	UpdatedAt                    time.Time     `json:"updated_at"`
}

type AssociatedWallet struct {
	ID          int32       `json:"id"`
	UserID      int32       `json:"user_id"`
	Wallet      string      `json:"wallet"`
	Blockhash   string      `json:"blockhash"`
	Blocknumber int32       `json:"blocknumber"`
	IsCurrent   bool        `json:"is_current"`
	IsDelete    bool        `json:"is_delete"`
	Chain       WalletChain `json:"chain"`
}

type AudioTransactionsHistory struct {
	UserBank             string         `json:"user_bank"`
	Slot                 int32          `json:"slot"`
	Signature            string         `json:"signature"`
	TransactionType      string         `json:"transaction_type"`
	Method               string         `json:"method"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
	TransactionCreatedAt time.Time      `json:"transaction_created_at"`
	Change               pgtype.Numeric `json:"change"`
	Balance              pgtype.Numeric `json:"balance"`
	TxMetadata           pgtype.Text    `json:"tx_metadata"`
}

type AudiusDataTx struct {
	Signature string `json:"signature"`
	Slot      int32  `json:"slot"`
}

type Block struct {
	Blockhash  string      `json:"blockhash"`
	Parenthash pgtype.Text `json:"parenthash"`
	IsCurrent  pgtype.Bool `json:"is_current"`
	Number     pgtype.Int4 `json:"number"`
}

type Challenge struct {
	ID            string        `json:"id"`
	Type          Challengetype `json:"type"`
	Amount        string        `json:"amount"`
	Active        bool          `json:"active"`
	StepCount     pgtype.Int4   `json:"step_count"`
	StartingBlock pgtype.Int4   `json:"starting_block"`
	WeeklyPool    pgtype.Int4   `json:"weekly_pool"`
	CooldownDays  pgtype.Int4   `json:"cooldown_days"`
}

type ChallengeDisbursement struct {
	ChallengeID string             `json:"challenge_id"`
	UserID      int32              `json:"user_id"`
	Specifier   string             `json:"specifier"`
	Signature   string             `json:"signature"`
	Slot        int32              `json:"slot"`
	Amount      string             `json:"amount"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

type ChallengeListenStreak struct {
	UserID         int32      `json:"user_id"`
	LastListenDate *time.Time `json:"last_listen_date"`
	ListenStreak   int32      `json:"listen_streak"`
}

type ChallengeProfileCompletion struct {
	UserID             int32 `json:"user_id"`
	ProfileDescription bool  `json:"profile_description"`
	ProfileName        bool  `json:"profile_name"`
	ProfilePicture     bool  `json:"profile_picture"`
	ProfileCoverPhoto  bool  `json:"profile_cover_photo"`
	Follows            bool  `json:"follows"`
	Favorites          bool  `json:"favorites"`
	Reposts            bool  `json:"reposts"`
}

type Chat struct {
	ChatID                 string      `json:"chat_id"`
	CreatedAt              time.Time   `json:"created_at"`
	LastMessageAt          time.Time   `json:"last_message_at"`
	LastMessage            pgtype.Text `json:"last_message"`
	LastMessageIsPlaintext pgtype.Bool `json:"last_message_is_plaintext"`
}

type ChatBan struct {
	UserID    int32     `json:"user_id"`
	IsBanned  bool      `json:"is_banned"`
	UpdatedAt time.Time `json:"updated_at"`
}

type ChatBlast struct {
	BlastID             string             `json:"blast_id"`
	FromUserID          int32              `json:"from_user_id"`
	Audience            string             `json:"audience"`
	AudienceContentID   pgtype.Int4        `json:"audience_content_id"`
	Plaintext           string             `json:"plaintext"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	AudienceContentType pgtype.Text        `json:"audience_content_type"`
}

type ChatBlockedUser struct {
	BlockerUserID int32     `json:"blocker_user_id"`
	BlockeeUserID int32     `json:"blockee_user_id"`
	CreatedAt     time.Time `json:"created_at"`
}

type ChatMember struct {
	ChatID           string     `json:"chat_id"`
	UserID           int32      `json:"user_id"`
	ClearedHistoryAt *time.Time `json:"cleared_history_at"`
	InvitedByUserID  int32      `json:"invited_by_user_id"`
	InviteCode       string     `json:"invite_code"`
	LastActiveAt     *time.Time `json:"last_active_at"`
	UnreadCount      int32      `json:"unread_count"`
	CreatedAt        time.Time  `json:"created_at"`
	IsHidden         bool       `json:"is_hidden"`
}

type ChatMessage struct {
	MessageID  string      `json:"message_id"`
	ChatID     string      `json:"chat_id"`
	UserID     int32       `json:"user_id"`
	CreatedAt  time.Time   `json:"created_at"`
	Ciphertext pgtype.Text `json:"ciphertext"`
	BlastID    pgtype.Text `json:"blast_id"`
}

type ChatMessageReaction struct {
	UserID    int32     `json:"user_id"`
	MessageID string    `json:"message_id"`
	Reaction  string    `json:"reaction"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type ChatPermission struct {
	UserID    int32     `json:"user_id"`
	Permits   string    `json:"permits"`
	UpdatedAt time.Time `json:"updated_at"`
	Allowed   bool      `json:"allowed"`
}

type CidDatum struct {
	Cid  string      `json:"cid"`
	Type pgtype.Text `json:"type"`
	Data []byte      `json:"data"`
}

// Stores collectibles data for users
type Collectible struct {
	// User ID of the person who owns the collectibles
	UserID int32 `json:"user_id"`
	// Data about the collectibles
	Data json.RawMessage `json:"data"`
	// Blockhash of the most recent block that changed the collectibles data
	Blockhash string `json:"blockhash"`
	// Block number of the most recent block that changed the collectibles data
	Blocknumber int32              `json:"blocknumber"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

type Comment struct {
	CommentID       int32       `json:"comment_id"`
	Text            string      `json:"text"`
	UserID          int32       `json:"user_id"`
	EntityID        int32       `json:"entity_id"`
	EntityType      string      `json:"entity_type"`
	TrackTimestampS pgtype.Int8 `json:"track_timestamp_s"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	IsDelete        pgtype.Bool `json:"is_delete"`
	IsVisible       pgtype.Bool `json:"is_visible"`
	IsEdited        pgtype.Bool `json:"is_edited"`
	Txhash          string      `json:"txhash"`
	Blockhash       string      `json:"blockhash"`
	Blocknumber     pgtype.Int4 `json:"blocknumber"`
}

type CommentMention struct {
	CommentID   int32       `json:"comment_id"`
	UserID      int32       `json:"user_id"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	IsDelete    pgtype.Bool `json:"is_delete"`
	Txhash      string      `json:"txhash"`
	Blockhash   string      `json:"blockhash"`
	Blocknumber pgtype.Int4 `json:"blocknumber"`
}

type CommentNotificationSetting struct {
	UserID     int32       `json:"user_id"`
	EntityID   int32       `json:"entity_id"`
	EntityType string      `json:"entity_type"`
	IsMuted    pgtype.Bool `json:"is_muted"`
	CreatedAt  time.Time   `json:"created_at"`
	UpdatedAt  time.Time   `json:"updated_at"`
}

type CommentReaction struct {
	CommentID   int32       `json:"comment_id"`
	UserID      int32       `json:"user_id"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	IsDelete    pgtype.Bool `json:"is_delete"`
	Txhash      string      `json:"txhash"`
	Blockhash   string      `json:"blockhash"`
	Blocknumber pgtype.Int4 `json:"blocknumber"`
}

type CommentReport struct {
	CommentID   int32       `json:"comment_id"`
	UserID      int32       `json:"user_id"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	IsDelete    pgtype.Bool `json:"is_delete"`
	Txhash      string      `json:"txhash"`
	Blockhash   string      `json:"blockhash"`
	Blocknumber pgtype.Int4 `json:"blocknumber"`
}

type CommentThread struct {
	CommentID       int32 `json:"comment_id"`
	ParentCommentID int32 `json:"parent_comment_id"`
}

type CoreAppState struct {
	BlockHeight int64      `json:"block_height"`
	AppHash     []byte     `json:"app_hash"`
	CreatedAt   *time.Time `json:"created_at"`
}

type CoreBlock struct {
	Rowid     int64     `json:"rowid"`
	Height    int64     `json:"height"`
	ChainID   string    `json:"chain_id"`
	Hash      string    `json:"hash"`
	Proposer  string    `json:"proposer"`
	CreatedAt time.Time `json:"created_at"`
}

type CoreDbMigration struct {
	ID        string             `json:"id"`
	AppliedAt pgtype.Timestamptz `json:"applied_at"`
}

type CoreErn struct {
	ID                 int64    `json:"id"`
	Address            string   `json:"address"`
	Index              int64    `json:"index"`
	TxHash             string   `json:"tx_hash"`
	Sender             string   `json:"sender"`
	MessageControlType int16    `json:"message_control_type"`
	PartyAddresses     []string `json:"party_addresses"`
	ResourceAddresses  []string `json:"resource_addresses"`
	ReleaseAddresses   []string `json:"release_addresses"`
	DealAddresses      []string `json:"deal_addresses"`
	RawMessage         []byte   `json:"raw_message"`
	RawAcknowledgment  []byte   `json:"raw_acknowledgment"`
	BlockHeight        int64    `json:"block_height"`
}

type CoreIndexedBlock struct {
	Blockhash  string      `json:"blockhash"`
	Parenthash pgtype.Text `json:"parenthash"`
	ChainID    string      `json:"chain_id"`
	Height     int32       `json:"height"`
	PlaysSlot  pgtype.Int4 `json:"plays_slot"`
	EmBlock    pgtype.Int4 `json:"em_block"`
}

type CoreMead struct {
	ID                int64    `json:"id"`
	Address           string   `json:"address"`
	TxHash            string   `json:"tx_hash"`
	Index             int64    `json:"index"`
	Sender            string   `json:"sender"`
	ResourceAddresses []string `json:"resource_addresses"`
	ReleaseAddresses  []string `json:"release_addresses"`
	RawMessage        []byte   `json:"raw_message"`
	RawAcknowledgment []byte   `json:"raw_acknowledgment"`
	BlockHeight       int64    `json:"block_height"`
}

type CorePie struct {
	ID                int64    `json:"id"`
	Address           string   `json:"address"`
	TxHash            string   `json:"tx_hash"`
	Index             int64    `json:"index"`
	Sender            string   `json:"sender"`
	PartyAddresses    []string `json:"party_addresses"`
	RawMessage        []byte   `json:"raw_message"`
	RawAcknowledgment []byte   `json:"raw_acknowledgment"`
	BlockHeight       int64    `json:"block_height"`
}

type CoreTransaction struct {
	Rowid       int64     `json:"rowid"`
	BlockID     int64     `json:"block_id"`
	Index       int32     `json:"index"`
	TxHash      string    `json:"tx_hash"`
	Transaction []byte    `json:"transaction"`
	CreatedAt   time.Time `json:"created_at"`
}

type CoreTxStat struct {
	ID          int32      `json:"id"`
	TxType      string     `json:"tx_type"`
	TxHash      string     `json:"tx_hash"`
	BlockHeight int64      `json:"block_height"`
	CreatedAt   *time.Time `json:"created_at"`
}

type CoreValidator struct {
	Rowid        int32  `json:"rowid"`
	PubKey       string `json:"pub_key"`
	Endpoint     string `json:"endpoint"`
	EthAddress   string `json:"eth_address"`
	CometAddress string `json:"comet_address"`
	EthBlock     string `json:"eth_block"`
	NodeType     string `json:"node_type"`
	SpID         string `json:"sp_id"`
	CometPubKey  string `json:"comet_pub_key"`
}

type Country struct {
	Iso       string      `json:"iso"`
	Name      string      `json:"name"`
	Nicename  string      `json:"nicename"`
	Iso3      pgtype.Text `json:"iso3"`
	Numcode   pgtype.Int2 `json:"numcode"`
	Phonecode int32       `json:"phonecode"`
}

type DashboardWalletUser struct {
	Wallet      string      `json:"wallet"`
	UserID      int32       `json:"user_id"`
	IsDelete    bool        `json:"is_delete"`
	UpdatedAt   time.Time   `json:"updated_at"`
	CreatedAt   time.Time   `json:"created_at"`
	Blockhash   pgtype.Text `json:"blockhash"`
	Blocknumber pgtype.Int4 `json:"blocknumber"`
	Txhash      string      `json:"txhash"`
}

type DelistStatusCursor struct {
	Host      string             `json:"host"`
	Entity    DelistEntity       `json:"entity"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type DeveloperApp struct {
	Address          string         `json:"address"`
	Blockhash        pgtype.Text    `json:"blockhash"`
	Blocknumber      pgtype.Int4    `json:"blocknumber"`
	UserID           trashid.HashId `json:"user_id"`
	Name             string         `json:"name"`
	IsPersonalAccess bool           `json:"is_personal_access"`
	IsDelete         bool           `json:"is_delete"`
	CreatedAt        time.Time      `json:"created_at"`
	Txhash           string         `json:"txhash"`
	IsCurrent        bool           `json:"is_current"`
	UpdatedAt        time.Time      `json:"updated_at"`
	Description      pgtype.Text    `json:"description"`
	ImageUrl         pgtype.Text    `json:"image_url"`
}

// Tracks who has access to encrypted emails
type EmailAccess struct {
	ID int32 `json:"id"`
	// The user ID of the email owner
	EmailOwnerUserID int32 `json:"email_owner_user_id"`
	// The user ID of the person granted access
	ReceivingUserID int32 `json:"receiving_user_id"`
	// The user ID of the person who granted access
	GrantorUserID int32 `json:"grantor_user_id"`
	// The symmetric key (SK) encrypted for the receiving user
	EncryptedKey string             `json:"encrypted_key"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	IsInitial    bool               `json:"is_initial"`
}

// Stores encrypted email addresses
type EncryptedEmail struct {
	ID int32 `json:"id"`
	// The user ID of the email owner
	EmailOwnerUserID int32 `json:"email_owner_user_id"`
	// The encrypted email address (base64 encoded)
	EncryptedEmail string             `json:"encrypted_email"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

type EthBlock struct {
	LastScannedBlock int32     `json:"last_scanned_block"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
}

type EthDbMigration struct {
	Version int64 `json:"version"`
	Dirty   bool  `json:"dirty"`
}

type EthFundingRound struct {
	RoundNum     int32     `json:"round_num"`
	Blocknumber  int64     `json:"blocknumber"`
	CreationTime time.Time `json:"creation_time"`
}

type EthRegisteredEndpoint struct {
	ID             int32     `json:"id"`
	ServiceType    string    `json:"service_type"`
	Owner          string    `json:"owner"`
	DelegateWallet string    `json:"delegate_wallet"`
	Endpoint       string    `json:"endpoint"`
	Blocknumber    int64     `json:"blocknumber"`
	RegisteredAt   time.Time `json:"registered_at"`
}

type EthServiceProvider struct {
	Address           string `json:"address"`
	DeployerStake     int64  `json:"deployer_stake"`
	DeployerCut       int64  `json:"deployer_cut"`
	ValidBounds       bool   `json:"valid_bounds"`
	NumberOfEndpoints int32  `json:"number_of_endpoints"`
	MinAccountStake   int64  `json:"min_account_stake"`
	MaxAccountStake   int64  `json:"max_account_stake"`
}

type EthStaked struct {
	Address     string `json:"address"`
	TotalStaked int64  `json:"total_staked"`
}

type Event struct {
	EventID     int32               `json:"event_id"`
	EventType   EventType           `json:"event_type"`
	UserID      int32               `json:"user_id"`
	EntityType  NullEventEntityType `json:"entity_type"`
	EntityID    pgtype.Int4         `json:"entity_id"`
	EndDate     *time.Time          `json:"end_date"`
	IsDeleted   pgtype.Bool         `json:"is_deleted"`
	EventData   *EventData          `json:"event_data"`
	CreatedAt   time.Time           `json:"created_at"`
	UpdatedAt   time.Time           `json:"updated_at"`
	Txhash      string              `json:"txhash"`
	Blockhash   string              `json:"blockhash"`
	Blocknumber pgtype.Int4         `json:"blocknumber"`
}

type Follow struct {
	Blockhash      pgtype.Text `json:"blockhash"`
	Blocknumber    pgtype.Int4 `json:"blocknumber"`
	FollowerUserID int32       `json:"follower_user_id"`
	FolloweeUserID int32       `json:"followee_user_id"`
	IsCurrent      bool        `json:"is_current"`
	IsDelete       bool        `json:"is_delete"`
	CreatedAt      time.Time   `json:"created_at"`
	Txhash         string      `json:"txhash"`
	Slot           pgtype.Int4 `json:"slot"`
}

type Grant struct {
	Blockhash      pgtype.Text    `json:"blockhash"`
	Blocknumber    pgtype.Int4    `json:"blocknumber"`
	GranteeAddress string         `json:"grantee_address"`
	UserID         trashid.HashId `json:"user_id"`
	IsRevoked      bool           `json:"is_revoked"`
	IsCurrent      bool           `json:"is_current"`
	IsApproved     pgtype.Bool    `json:"is_approved"`
	UpdatedAt      time.Time      `json:"updated_at"`
	CreatedAt      time.Time      `json:"created_at"`
	Txhash         string         `json:"txhash"`
}

type HourlyPlayCount struct {
	HourlyTimestamp time.Time `json:"hourly_timestamp"`
	PlayCount       int32     `json:"play_count"`
}

type IndexingCheckpoint struct {
	Tablename      string      `json:"tablename"`
	LastCheckpoint int32       `json:"last_checkpoint"`
	Signature      pgtype.Text `json:"signature"`
}

type ManagementKey struct {
	ID      int32  `json:"id"`
	TrackID string `json:"track_id"`
	Address string `json:"address"`
}

type Milestone struct {
	ID          int32       `json:"id"`
	Name        string      `json:"name"`
	Threshold   int32       `json:"threshold"`
	Blocknumber pgtype.Int4 `json:"blocknumber"`
	Slot        pgtype.Int4 `json:"slot"`
	Timestamp   time.Time   `json:"timestamp"`
}

type MutedUser struct {
	MutedUserID int32       `json:"muted_user_id"`
	UserID      int32       `json:"user_id"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	IsDelete    pgtype.Bool `json:"is_delete"`
	Txhash      string      `json:"txhash"`
	Blockhash   string      `json:"blockhash"`
	Blocknumber pgtype.Int4 `json:"blocknumber"`
}

type Notification struct {
	ID          int32       `json:"id"`
	Specifier   string      `json:"specifier"`
	GroupID     string      `json:"group_id"`
	Type        string      `json:"type"`
	Slot        pgtype.Int4 `json:"slot"`
	Blocknumber pgtype.Int4 `json:"blocknumber"`
	Timestamp   time.Time   `json:"timestamp"`
	Data        []byte      `json:"data"`
	UserIds     []int32     `json:"user_ids"`
	TypeV2      pgtype.Text `json:"type_v2"`
}

type NotificationSeen struct {
	UserID      int32       `json:"user_id"`
	SeenAt      time.Time   `json:"seen_at"`
	Blocknumber pgtype.Int4 `json:"blocknumber"`
	Blockhash   pgtype.Text `json:"blockhash"`
	Txhash      pgtype.Text `json:"txhash"`
}

type PaymentRouterTx struct {
	Signature string    `json:"signature"`
	Slot      int32     `json:"slot"`
	CreatedAt time.Time `json:"created_at"`
}

type Play struct {
	ID         int32       `json:"id"`
	UserID     pgtype.Int4 `json:"user_id"`
	Source     pgtype.Text `json:"source"`
	PlayItemID int32       `json:"play_item_id"`
	CreatedAt  time.Time   `json:"created_at"`
	UpdatedAt  time.Time   `json:"updated_at"`
	Slot       pgtype.Int4 `json:"slot"`
	Signature  pgtype.Text `json:"signature"`
	City       pgtype.Text `json:"city"`
	Region     pgtype.Text `json:"region"`
	Country    pgtype.Text `json:"country"`
}

type Playlist struct {
	Blockhash                   pgtype.Text      `json:"blockhash"`
	Blocknumber                 pgtype.Int4      `json:"blocknumber"`
	PlaylistID                  int32            `json:"playlist_id"`
	PlaylistOwnerID             int32            `json:"playlist_owner_id"`
	IsAlbum                     bool             `json:"is_album"`
	IsPrivate                   bool             `json:"is_private"`
	PlaylistName                pgtype.Text      `json:"playlist_name"`
	PlaylistContents            PlaylistContents `json:"playlist_contents"`
	PlaylistImageMultihash      pgtype.Text      `json:"playlist_image_multihash"`
	IsCurrent                   bool             `json:"is_current"`
	IsDelete                    bool             `json:"is_delete"`
	Description                 pgtype.Text      `json:"description"`
	CreatedAt                   time.Time        `json:"created_at"`
	Upc                         pgtype.Text      `json:"upc"`
	UpdatedAt                   time.Time        `json:"updated_at"`
	PlaylistImageSizesMultihash pgtype.Text      `json:"playlist_image_sizes_multihash"`
	Txhash                      string           `json:"txhash"`
	LastAddedTo                 *time.Time       `json:"last_added_to"`
	Slot                        pgtype.Int4      `json:"slot"`
	MetadataMultihash           pgtype.Text      `json:"metadata_multihash"`
	IsImageAutogenerated        bool             `json:"is_image_autogenerated"`
	StreamConditions            *AccessGate      `json:"stream_conditions"`
	DdexApp                     pgtype.Text      `json:"ddex_app"`
	DdexReleaseIds              []byte           `json:"ddex_release_ids"`
	Artists                     []byte           `json:"artists"`
	CopyrightLine               []byte           `json:"copyright_line"`
	ProducerCopyrightLine       []byte           `json:"producer_copyright_line"`
	ParentalWarningType         pgtype.Text      `json:"parental_warning_type"`
	IsScheduledRelease          bool             `json:"is_scheduled_release"`
	ReleaseDate                 *time.Time       `json:"release_date"`
	IsStreamGated               pgtype.Bool      `json:"is_stream_gated"`
}

type PlaylistRoute struct {
	Slug        string `json:"slug"`
	TitleSlug   string `json:"title_slug"`
	CollisionID int32  `json:"collision_id"`
	OwnerID     int32  `json:"owner_id"`
	PlaylistID  int32  `json:"playlist_id"`
	IsCurrent   bool   `json:"is_current"`
	Blockhash   string `json:"blockhash"`
	Blocknumber int32  `json:"blocknumber"`
	Txhash      string `json:"txhash"`
}

type PlaylistSeen struct {
	UserID      int32       `json:"user_id"`
	PlaylistID  int32       `json:"playlist_id"`
	SeenAt      time.Time   `json:"seen_at"`
	IsCurrent   bool        `json:"is_current"`
	Blocknumber pgtype.Int4 `json:"blocknumber"`
	Blockhash   pgtype.Text `json:"blockhash"`
	Txhash      pgtype.Text `json:"txhash"`
}

type PlaylistTrack struct {
	PlaylistID int32              `json:"playlist_id"`
	TrackID    int32              `json:"track_id"`
	IsRemoved  bool               `json:"is_removed"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

type PlaylistTrendingScore struct {
	PlaylistID int32     `json:"playlist_id"`
	Type       string    `json:"type"`
	Version    string    `json:"version"`
	TimeRange  string    `json:"time_range"`
	Score      float64   `json:"score"`
	CreatedAt  time.Time `json:"created_at"`
}

type Reaction struct {
	ID            int32       `json:"id"`
	ReactionValue int32       `json:"reaction_value"`
	SenderWallet  string      `json:"sender_wallet"`
	ReactionType  string      `json:"reaction_type"`
	ReactedTo     string      `json:"reacted_to"`
	Timestamp     time.Time   `json:"timestamp"`
	Blocknumber   pgtype.Int4 `json:"blocknumber"`
}

type RelatedArtist struct {
	UserID              int32     `json:"user_id"`
	RelatedArtistUserID int32     `json:"related_artist_user_id"`
	Score               float64   `json:"score"`
	CreatedAt           time.Time `json:"created_at"`
}

type Remix struct {
	ParentTrackID int32 `json:"parent_track_id"`
	ChildTrackID  int32 `json:"child_track_id"`
}

type ReportedComment struct {
	ReportedCommentID int32       `json:"reported_comment_id"`
	UserID            int32       `json:"user_id"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`
	Txhash            string      `json:"txhash"`
	Blockhash         string      `json:"blockhash"`
	Blocknumber       pgtype.Int4 `json:"blocknumber"`
}

type Repost struct {
	Blockhash        pgtype.Text `json:"blockhash"`
	Blocknumber      pgtype.Int4 `json:"blocknumber"`
	UserID           int32       `json:"user_id"`
	RepostItemID     int32       `json:"repost_item_id"`
	RepostType       Reposttype  `json:"repost_type"`
	IsCurrent        bool        `json:"is_current"`
	IsDelete         bool        `json:"is_delete"`
	CreatedAt        time.Time   `json:"created_at"`
	Txhash           string      `json:"txhash"`
	Slot             pgtype.Int4 `json:"slot"`
	IsRepostOfRepost bool        `json:"is_repost_of_repost"`
}

type RevertBlock struct {
	Blocknumber int32           `json:"blocknumber"`
	PrevRecords json.RawMessage `json:"prev_records"`
}

type RewardManagerTx struct {
	Signature string    `json:"signature"`
	Slot      int32     `json:"slot"`
	CreatedAt time.Time `json:"created_at"`
}

type RouteMetric struct {
	RoutePath   string      `json:"route_path"`
	Version     string      `json:"version"`
	QueryString string      `json:"query_string"`
	Count       int32       `json:"count"`
	Timestamp   time.Time   `json:"timestamp"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	ID          int64       `json:"id"`
	Ip          pgtype.Text `json:"ip"`
}

type RouteMetricsAllTime struct {
	UniqueCount int64 `json:"unique_count"`
	Count       int64 `json:"count"`
}

type RouteMetricsDayBucket struct {
	UniqueCount int64           `json:"unique_count"`
	Count       int64           `json:"count"`
	Time        pgtype.Interval `json:"time"`
}

type RouteMetricsMonthBucket struct {
	UniqueCount int64           `json:"unique_count"`
	Count       int64           `json:"count"`
	Time        pgtype.Interval `json:"time"`
}

type RouteMetricsTrailingMonth struct {
	UniqueCount int64 `json:"unique_count"`
	Count       int64 `json:"count"`
}

type RouteMetricsTrailingWeek struct {
	UniqueCount int64 `json:"unique_count"`
	Count       int64 `json:"count"`
}

type RpcCursor struct {
	RelayedBy string    `json:"relayed_by"`
	RelayedAt time.Time `json:"relayed_at"`
}

type RpcError struct {
	Sig         string          `json:"sig"`
	RpcLogJson  json.RawMessage `json:"rpc_log_json"`
	ErrorText   string          `json:"error_text"`
	ErrorCount  int32           `json:"error_count"`
	LastAttempt time.Time       `json:"last_attempt"`
}

type RpcLog struct {
	RelayedAt  time.Time `json:"relayed_at"`
	FromWallet string    `json:"from_wallet"`
	Rpc        []byte    `json:"rpc"`
	Sig        string    `json:"sig"`
	RelayedBy  string    `json:"relayed_by"`
	AppliedAt  time.Time `json:"applied_at"`
}

type Safe struct {
	Blockhash      pgtype.Text `json:"blockhash"`
	Blocknumber    pgtype.Int4 `json:"blocknumber"`
	UserID         int32       `json:"user_id"`
	SaveItemID     int32       `json:"save_item_id"`
	SaveType       Savetype    `json:"save_type"`
	IsCurrent      bool        `json:"is_current"`
	IsDelete       bool        `json:"is_delete"`
	CreatedAt      time.Time   `json:"created_at"`
	Txhash         string      `json:"txhash"`
	Slot           pgtype.Int4 `json:"slot"`
	IsSaveOfRepost bool        `json:"is_save_of_repost"`
}

type SchemaMigration struct {
	Version string `json:"version"`
}

type SchemaVersion struct {
	FileName  string             `json:"file_name"`
	Md5       pgtype.Text        `json:"md5"`
	AppliedAt pgtype.Timestamptz `json:"applied_at"`
}

type Share struct {
	Blockhash   pgtype.Text `json:"blockhash"`
	Blocknumber pgtype.Int4 `json:"blocknumber"`
	UserID      int32       `json:"user_id"`
	ShareItemID int32       `json:"share_item_id"`
	ShareType   Sharetype   `json:"share_type"`
	CreatedAt   time.Time   `json:"created_at"`
	Txhash      string      `json:"txhash"`
	Slot        pgtype.Int4 `json:"slot"`
}

type SkippedTransaction struct {
	ID          int32                   `json:"id"`
	Blocknumber int32                   `json:"blocknumber"`
	Blockhash   string                  `json:"blockhash"`
	Txhash      string                  `json:"txhash"`
	CreatedAt   time.Time               `json:"created_at"`
	UpdatedAt   time.Time               `json:"updated_at"`
	Level       Skippedtransactionlevel `json:"level"`
}

type SlaAuditorVersionDatum struct {
	ID           int32              `json:"id"`
	NodeEndpoint string             `json:"node_endpoint"`
	NodeVersion  string             `json:"node_version"`
	MinVersion   string             `json:"min_version"`
	Owner        string             `json:"owner"`
	Ok           bool               `json:"ok"`
	Timestamp    pgtype.Timestamptz `json:"timestamp"`
}

type SlaNodeReport struct {
	ID             int32       `json:"id"`
	Address        string      `json:"address"`
	BlocksProposed int32       `json:"blocks_proposed"`
	SlaRollupID    pgtype.Int4 `json:"sla_rollup_id"`
}

type SlaRollup struct {
	ID         int32     `json:"id"`
	TxHash     string    `json:"tx_hash"`
	BlockStart int64     `json:"block_start"`
	BlockEnd   int64     `json:"block_end"`
	Time       time.Time `json:"time"`
}

// Stores claimable tokens program Create instructions for tracked mints.
type SolClaimableAccount struct {
	Signature        string `json:"signature"`
	InstructionIndex int32  `json:"instruction_index"`
	Slot             int64  `json:"slot"`
	Mint             string `json:"mint"`
	EthereumAddress  string `json:"ethereum_address"`
	Account          string `json:"account"`
}

// Stores claimable tokens program Transfer instructions for tracked mints.
type SolClaimableAccountTransfer struct {
	Signature        string `json:"signature"`
	InstructionIndex int32  `json:"instruction_index"`
	Amount           int64  `json:"amount"`
	Slot             int64  `json:"slot"`
	FromAccount      string `json:"from_account"`
	ToAccount        string `json:"to_account"`
	SenderEthAddress string `json:"sender_eth_address"`
}

// Stores payment router program Route instruction recipients and amounts for tracked mints.
type SolPayment struct {
	Signature        string `json:"signature"`
	InstructionIndex int32  `json:"instruction_index"`
	Amount           int64  `json:"amount"`
	Slot             int64  `json:"slot"`
	RouteIndex       int32  `json:"route_index"`
	ToAccount        string `json:"to_account"`
}

// Stores payment router program Route instructions that are paired with purchase information for tracked mints.
type SolPurchase struct {
	Signature        string `json:"signature"`
	InstructionIndex int32  `json:"instruction_index"`
	Amount           int64  `json:"amount"`
	Slot             int64  `json:"slot"`
	FromAccount      string `json:"from_account"`
	ContentType      string `json:"content_type"`
	ContentID        int32  `json:"content_id"`
	BuyerUserID      int32  `json:"buyer_user_id"`
	AccessType       string `json:"access_type"`
	// Purchase transactions include the blocknumber that the content was most recently updated in order to ensure that the relevant pricing information has been indexed before evaluating whether the purchase is valid.
	ValidAfterBlocknumber int64 `json:"valid_after_blocknumber"`
	// A purchase is valid if it meets the pricing information set by the artist. If the pricing information is not available yet (as indicated by the valid_after_blocknumber), then is_valid will be NULL which indicates a "pending" state.
	IsValid pgtype.Bool `json:"is_valid"`
	City    pgtype.Text `json:"city"`
	Region  pgtype.Text `json:"region"`
	Country pgtype.Text `json:"country"`
}

// Stores reward manager program Evaluate instructions for tracked mints.
type SolRewardDisbursement struct {
	Signature        string `json:"signature"`
	InstructionIndex int32  `json:"instruction_index"`
	Amount           int64  `json:"amount"`
	Slot             int64  `json:"slot"`
	UserBank         string `json:"user_bank"`
	ChallengeID      string `json:"challenge_id"`
	Specifier        string `json:"specifier"`
}

// Stores checkpoints for Solana slots to track indexing progress.
type SolSlotCheckpoint struct {
	ID               pgtype.UUID     `json:"id"`
	FromSlot         int64           `json:"from_slot"`
	ToSlot           int64           `json:"to_slot"`
	SubscriptionHash string          `json:"subscription_hash"`
	Subscription     json.RawMessage `json:"subscription"`
	UpdatedAt        time.Time       `json:"updated_at"`
	CreatedAt        time.Time       `json:"created_at"`
}

// Stores eg. Jupiter swaps for tracked mints.
type SolSwap struct {
	Signature        string `json:"signature"`
	InstructionIndex int32  `json:"instruction_index"`
	Slot             int64  `json:"slot"`
	FromMint         string `json:"from_mint"`
	FromAccount      string `json:"from_account"`
	FromAmount       int64  `json:"from_amount"`
	ToMint           string `json:"to_mint"`
	ToAccount        string `json:"to_account"`
	ToAmount         int64  `json:"to_amount"`
}

// Stores current token balances for all accounts of tracked mints.
type SolTokenAccountBalance struct {
	Account   string    `json:"account"`
	Mint      string    `json:"mint"`
	Owner     string    `json:"owner"`
	Balance   int64     `json:"balance"`
	Slot      int64     `json:"slot"`
	UpdatedAt time.Time `json:"updated_at"`
	CreatedAt time.Time `json:"created_at"`
}

// Stores token balance changes for all accounts of tracked mints.
type SolTokenAccountBalanceChange struct {
	Signature      string    `json:"signature"`
	Mint           string    `json:"mint"`
	Owner          string    `json:"owner"`
	Account        string    `json:"account"`
	Change         int64     `json:"change"`
	Balance        int64     `json:"balance"`
	Slot           int64     `json:"slot"`
	UpdatedAt      time.Time `json:"updated_at"`
	CreatedAt      time.Time `json:"created_at"`
	BlockTimestamp time.Time `json:"block_timestamp"`
}

// Stores SPL token transfers for tracked mints.
type SolTokenTransfer struct {
	Signature        string `json:"signature"`
	InstructionIndex int32  `json:"instruction_index"`
	Amount           int64  `json:"amount"`
	Slot             int64  `json:"slot"`
	FromAccount      string `json:"from_account"`
	ToAccount        string `json:"to_account"`
}

type SolUnprocessedTx struct {
	Signature    string      `json:"signature"`
	ErrorMessage pgtype.Text `json:"error_message"`
	CreatedAt    time.Time   `json:"created_at"`
	UpdatedAt    time.Time   `json:"updated_at"`
	Slot         int64       `json:"slot"`
}

// Stores the balances of Solana tokens for users.
type SolUserBalance struct {
	UserID    int32     `json:"user_id"`
	Mint      string    `json:"mint"`
	Balance   int64     `json:"balance"`
	UpdatedAt time.Time `json:"updated_at"`
	CreatedAt time.Time `json:"created_at"`
}

type SoundRecording struct {
	ID               int32       `json:"id"`
	SoundRecordingID string      `json:"sound_recording_id"`
	TrackID          string      `json:"track_id"`
	Cid              string      `json:"cid"`
	EncodingDetails  pgtype.Text `json:"encoding_details"`
}

type SplTokenTx struct {
	LastScannedSlot int32              `json:"last_scanned_slot"`
	Signature       string             `json:"signature"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

type Stem struct {
	ParentTrackID int32 `json:"parent_track_id"`
	ChildTrackID  int32 `json:"child_track_id"`
}

type StorageProof struct {
	ID              int32       `json:"id"`
	BlockHeight     int64       `json:"block_height"`
	Address         string      `json:"address"`
	Cid             pgtype.Text `json:"cid"`
	ProofSignature  pgtype.Text `json:"proof_signature"`
	Proof           pgtype.Text `json:"proof"`
	ProverAddresses []string    `json:"prover_addresses"`
	Status          ProofStatus `json:"status"`
}

type StorageProofPeer struct {
	ID              int32    `json:"id"`
	BlockHeight     int64    `json:"block_height"`
	ProverAddresses []string `json:"prover_addresses"`
}

type Subscription struct {
	Blockhash    pgtype.Text `json:"blockhash"`
	Blocknumber  pgtype.Int4 `json:"blocknumber"`
	SubscriberID int32       `json:"subscriber_id"`
	UserID       int32       `json:"user_id"`
	IsCurrent    bool        `json:"is_current"`
	IsDelete     bool        `json:"is_delete"`
	CreatedAt    time.Time   `json:"created_at"`
	Txhash       string      `json:"txhash"`
}

type SupporterRankUp struct {
	Slot           int32 `json:"slot"`
	SenderUserID   int32 `json:"sender_user_id"`
	ReceiverUserID int32 `json:"receiver_user_id"`
	Rank           int32 `json:"rank"`
}

type TagTrackUser struct {
	Tag     interface{} `json:"tag"`
	TrackID int32       `json:"track_id"`
	OwnerID int32       `json:"owner_id"`
}

type Track struct {
	Blockhash                          pgtype.Text     `json:"blockhash"`
	TrackID                            int32           `json:"track_id"`
	IsCurrent                          bool            `json:"is_current"`
	IsDelete                           bool            `json:"is_delete"`
	OwnerID                            int32           `json:"owner_id"`
	Title                              pgtype.Text     `json:"title"`
	CoverArt                           pgtype.Text     `json:"cover_art"`
	Tags                               pgtype.Text     `json:"tags"`
	Genre                              pgtype.Text     `json:"genre"`
	Mood                               pgtype.Text     `json:"mood"`
	CreditsSplits                      pgtype.Text     `json:"credits_splits"`
	CreateDate                         pgtype.Text     `json:"create_date"`
	FileType                           pgtype.Text     `json:"file_type"`
	MetadataMultihash                  pgtype.Text     `json:"metadata_multihash"`
	Blocknumber                        pgtype.Int4     `json:"blocknumber"`
	CreatedAt                          time.Time       `json:"created_at"`
	Description                        pgtype.Text     `json:"description"`
	Isrc                               pgtype.Text     `json:"isrc"`
	Iswc                               pgtype.Text     `json:"iswc"`
	License                            pgtype.Text     `json:"license"`
	UpdatedAt                          time.Time       `json:"updated_at"`
	CoverArtSizes                      pgtype.Text     `json:"cover_art_sizes"`
	IsUnlisted                         bool            `json:"is_unlisted"`
	FieldVisibility                    json.RawMessage `json:"field_visibility"`
	RouteID                            pgtype.Text     `json:"route_id"`
	StemOf                             []byte          `json:"stem_of"`
	RemixOf                            []byte          `json:"remix_of"`
	Txhash                             string          `json:"txhash"`
	Slot                               pgtype.Int4     `json:"slot"`
	IsAvailable                        bool            `json:"is_available"`
	StreamConditions                   *AccessGate     `json:"stream_conditions"`
	TrackCid                           pgtype.Text     `json:"track_cid"`
	IsPlaylistUpload                   bool            `json:"is_playlist_upload"`
	Duration                           pgtype.Int4     `json:"duration"`
	AiAttributionUserID                pgtype.Int4     `json:"ai_attribution_user_id"`
	PreviewCid                         pgtype.Text     `json:"preview_cid"`
	AudioUploadID                      pgtype.Text     `json:"audio_upload_id"`
	PreviewStartSeconds                pgtype.Float8   `json:"preview_start_seconds"`
	ReleaseDate                        *time.Time      `json:"release_date"`
	TrackSegments                      json.RawMessage `json:"track_segments"`
	IsScheduledRelease                 bool            `json:"is_scheduled_release"`
	IsDownloadable                     bool            `json:"is_downloadable"`
	DownloadConditions                 *AccessGate     `json:"download_conditions"`
	IsOriginalAvailable                bool            `json:"is_original_available"`
	OrigFileCid                        pgtype.Text     `json:"orig_file_cid"`
	OrigFilename                       pgtype.Text     `json:"orig_filename"`
	PlaylistsContainingTrack           []int32         `json:"playlists_containing_track"`
	PlacementHosts                     pgtype.Text     `json:"placement_hosts"`
	DdexApp                            pgtype.Text     `json:"ddex_app"`
	DdexReleaseIds                     json.RawMessage `json:"ddex_release_ids"`
	Artists                            json.RawMessage `json:"artists"`
	ResourceContributors               json.RawMessage `json:"resource_contributors"`
	IndirectResourceContributors       json.RawMessage `json:"indirect_resource_contributors"`
	RightsController                   json.RawMessage `json:"rights_controller"`
	CopyrightLine                      json.RawMessage `json:"copyright_line"`
	ProducerCopyrightLine              json.RawMessage `json:"producer_copyright_line"`
	ParentalWarningType                pgtype.Text     `json:"parental_warning_type"`
	PlaylistsPreviouslyContainingTrack json.RawMessage `json:"playlists_previously_containing_track"`
	AllowedApiKeys                     []string        `json:"allowed_api_keys"`
	Bpm                                pgtype.Float8   `json:"bpm"`
	MusicalKey                         pgtype.Text     `json:"musical_key"`
	AudioAnalysisErrorCount            int32           `json:"audio_analysis_error_count"`
	IsCustomBpm                        pgtype.Bool     `json:"is_custom_bpm"`
	IsCustomMusicalKey                 pgtype.Bool     `json:"is_custom_musical_key"`
	CommentsDisabled                   pgtype.Bool     `json:"comments_disabled"`
	PinnedCommentID                    pgtype.Int4     `json:"pinned_comment_id"`
	// Title of the original song if this track is a cover
	CoverOriginalSongTitle pgtype.Text `json:"cover_original_song_title"`
	// Artist of the original song if this track is a cover
	CoverOriginalArtist pgtype.Text `json:"cover_original_artist"`
	// Indicates whether the track is owned by the user for publishing payouts
	IsOwnedByUser   bool                    `json:"is_owned_by_user"`
	IsStreamGated   pgtype.Bool             `json:"is_stream_gated"`
	IsDownloadGated pgtype.Bool             `json:"is_download_gated"`
	NoAiUse         pgtype.Bool             `json:"no_ai_use"`
	ParentalWarning NullParentalWarningType `json:"parental_warning"`
	TerritoryCodes  []string                `json:"territory_codes"`
}

type TrackDelistStatus struct {
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	TrackID   int32              `json:"track_id"`
	OwnerID   int32              `json:"owner_id"`
	TrackCid  string             `json:"track_cid"`
	Delisted  bool               `json:"delisted"`
	Reason    DelistTrackReason  `json:"reason"`
}

type TrackDownload struct {
	Txhash        string      `json:"txhash"`
	Blocknumber   int32       `json:"blocknumber"`
	ParentTrackID int32       `json:"parent_track_id"`
	TrackID       int32       `json:"track_id"`
	UserID        pgtype.Int4 `json:"user_id"`
	CreatedAt     time.Time   `json:"created_at"`
	City          pgtype.Text `json:"city"`
	Region        pgtype.Text `json:"region"`
	Country       pgtype.Text `json:"country"`
}

type TrackPriceHistory struct {
	TrackID         int32                  `json:"track_id"`
	Splits          json.RawMessage        `json:"splits"`
	TotalPriceCents int64                  `json:"total_price_cents"`
	Blocknumber     int32                  `json:"blocknumber"`
	BlockTimestamp  time.Time              `json:"block_timestamp"`
	CreatedAt       time.Time              `json:"created_at"`
	Access          UsdcPurchaseAccessType `json:"access"`
}

type TrackRelease struct {
	ID      int32  `json:"id"`
	TrackID string `json:"track_id"`
}

type TrackRoute struct {
	Slug        string `json:"slug"`
	TitleSlug   string `json:"title_slug"`
	CollisionID int32  `json:"collision_id"`
	OwnerID     int32  `json:"owner_id"`
	TrackID     int32  `json:"track_id"`
	IsCurrent   bool   `json:"is_current"`
	Blockhash   string `json:"blockhash"`
	Blocknumber int32  `json:"blocknumber"`
	Txhash      string `json:"txhash"`
}

type TrackTrendingScore struct {
	TrackID   int32       `json:"track_id"`
	Type      string      `json:"type"`
	Genre     pgtype.Text `json:"genre"`
	Version   string      `json:"version"`
	TimeRange string      `json:"time_range"`
	Score     float64     `json:"score"`
	CreatedAt time.Time   `json:"created_at"`
}

type TrendingParam struct {
	TrackID            int32       `json:"track_id"`
	ReleaseDate        *time.Time  `json:"release_date"`
	Genre              pgtype.Text `json:"genre"`
	OwnerID            int32       `json:"owner_id"`
	PlayCount          pgtype.Int8 `json:"play_count"`
	OwnerFollowerCount pgtype.Int8 `json:"owner_follower_count"`
	RepostCount        int32       `json:"repost_count"`
	SaveCount          int32       `json:"save_count"`
	RepostWeekCount    int64       `json:"repost_week_count"`
	RepostMonthCount   int64       `json:"repost_month_count"`
	RepostYearCount    int64       `json:"repost_year_count"`
	SaveWeekCount      int64       `json:"save_week_count"`
	SaveMonthCount     int64       `json:"save_month_count"`
	SaveYearCount      int64       `json:"save_year_count"`
	Karma              int64       `json:"karma"`
}

type TrendingResult struct {
	UserID  int32       `json:"user_id"`
	ID      pgtype.Text `json:"id"`
	Rank    int32       `json:"rank"`
	Type    string      `json:"type"`
	Version string      `json:"version"`
	Week    pgtype.Date `json:"week"`
}

type UsdcPurchase struct {
	Slot         int32                   `json:"slot"`
	Signature    string                  `json:"signature"`
	BuyerUserID  int32                   `json:"buyer_user_id"`
	SellerUserID int32                   `json:"seller_user_id"`
	Amount       int64                   `json:"amount"`
	ContentType  UsdcPurchaseContentType `json:"content_type"`
	ContentID    int32                   `json:"content_id"`
	CreatedAt    time.Time               `json:"created_at"`
	UpdatedAt    time.Time               `json:"updated_at"`
	ExtraAmount  int64                   `json:"extra_amount"`
	Access       UsdcPurchaseAccessType  `json:"access"`
	City         pgtype.Text             `json:"city"`
	Region       pgtype.Text             `json:"region"`
	Country      pgtype.Text             `json:"country"`
	Vendor       pgtype.Text             `json:"vendor"`
	Splits       json.RawMessage         `json:"splits"`
}

type UsdcTransactionsHistory struct {
	UserBank             string         `json:"user_bank"`
	Slot                 int32          `json:"slot"`
	Signature            string         `json:"signature"`
	TransactionType      string         `json:"transaction_type"`
	Method               string         `json:"method"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
	TransactionCreatedAt time.Time      `json:"transaction_created_at"`
	Change               pgtype.Numeric `json:"change"`
	Balance              pgtype.Numeric `json:"balance"`
	TxMetadata           pgtype.Text    `json:"tx_metadata"`
}

type UsdcUserBankAccount struct {
	Signature       string    `json:"signature"`
	EthereumAddress string    `json:"ethereum_address"`
	CreatedAt       time.Time `json:"created_at"`
	BankAccount     string    `json:"bank_account"`
}

type User struct {
	Blockhash              pgtype.Text     `json:"blockhash"`
	UserID                 trashid.HashId  `json:"user_id"`
	IsCurrent              bool            `json:"is_current"`
	Handle                 pgtype.Text     `json:"handle"`
	Wallet                 pgtype.Text     `json:"wallet"`
	Name                   pgtype.Text     `json:"name"`
	ProfilePicture         pgtype.Text     `json:"profile_picture"`
	CoverPhoto             pgtype.Text     `json:"cover_photo"`
	Bio                    pgtype.Text     `json:"bio"`
	Location               pgtype.Text     `json:"location"`
	MetadataMultihash      pgtype.Text     `json:"metadata_multihash"`
	CreatorNodeEndpoint    pgtype.Text     `json:"creator_node_endpoint"`
	Blocknumber            pgtype.Int4     `json:"blocknumber"`
	IsVerified             bool            `json:"is_verified"`
	CreatedAt              time.Time       `json:"created_at"`
	UpdatedAt              time.Time       `json:"updated_at"`
	HandleLc               pgtype.Text     `json:"handle_lc"`
	CoverPhotoSizes        pgtype.Text     `json:"cover_photo_sizes"`
	ProfilePictureSizes    pgtype.Text     `json:"profile_picture_sizes"`
	PrimaryID              pgtype.Int4     `json:"primary_id"`
	SecondaryIds           []int32         `json:"secondary_ids"`
	ReplicaSetUpdateSigner pgtype.Text     `json:"replica_set_update_signer"`
	HasCollectibles        bool            `json:"has_collectibles"`
	Txhash                 string          `json:"txhash"`
	PlaylistLibrary        json.RawMessage `json:"playlist_library"`
	IsDeactivated          bool            `json:"is_deactivated"`
	Slot                   pgtype.Int4     `json:"slot"`
	UserStorageAccount     pgtype.Text     `json:"user_storage_account"`
	UserAuthorityAccount   pgtype.Text     `json:"user_authority_account"`
	ArtistPickTrackID      pgtype.Int4     `json:"artist_pick_track_id"`
	IsAvailable            bool            `json:"is_available"`
	IsStorageV2            bool            `json:"is_storage_v2"`
	AllowAiAttribution     bool            `json:"allow_ai_attribution"`
	SplUsdcPayoutWallet    pgtype.Text     `json:"spl_usdc_payout_wallet"`
	TwitterHandle          pgtype.Text     `json:"twitter_handle"`
	InstagramHandle        pgtype.Text     `json:"instagram_handle"`
	TiktokHandle           pgtype.Text     `json:"tiktok_handle"`
	VerifiedWithTwitter    pgtype.Bool     `json:"verified_with_twitter"`
	VerifiedWithInstagram  pgtype.Bool     `json:"verified_with_instagram"`
	VerifiedWithTiktok     pgtype.Bool     `json:"verified_with_tiktok"`
	Website                pgtype.Text     `json:"website"`
	Donation               pgtype.Text     `json:"donation"`
	ProfileType            *string         `json:"profile_type"`
}

type UserBalance struct {
	UserID                      int32       `json:"user_id"`
	Balance                     string      `json:"balance"`
	CreatedAt                   time.Time   `json:"created_at"`
	UpdatedAt                   time.Time   `json:"updated_at"`
	AssociatedWalletsBalance    string      `json:"associated_wallets_balance"`
	Waudio                      pgtype.Text `json:"waudio"`
	AssociatedSolWalletsBalance string      `json:"associated_sol_wallets_balance"`
}

type UserBalanceChange struct {
	UserID          int32     `json:"user_id"`
	Blocknumber     int32     `json:"blocknumber"`
	CurrentBalance  string    `json:"current_balance"`
	PreviousBalance string    `json:"previous_balance"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
}

type UserBankAccount struct {
	Signature       string    `json:"signature"`
	EthereumAddress string    `json:"ethereum_address"`
	CreatedAt       time.Time `json:"created_at"`
	BankAccount     string    `json:"bank_account"`
}

type UserBankTx struct {
	Signature string    `json:"signature"`
	Slot      int32     `json:"slot"`
	CreatedAt time.Time `json:"created_at"`
}

type UserChallenge struct {
	ChallengeID          string             `json:"challenge_id"`
	UserID               int32              `json:"user_id"`
	Specifier            string             `json:"specifier"`
	IsComplete           bool               `json:"is_complete"`
	CurrentStepCount     pgtype.Int4        `json:"current_step_count"`
	CompletedBlocknumber pgtype.Int4        `json:"completed_blocknumber"`
	Amount               int32              `json:"amount"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	CompletedAt          *time.Time         `json:"completed_at"`
}

type UserDelistStatus struct {
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UserID    int32              `json:"user_id"`
	Delisted  bool               `json:"delisted"`
	Reason    DelistUserReason   `json:"reason"`
}

type UserEvent struct {
	ID           int32       `json:"id"`
	Blockhash    pgtype.Text `json:"blockhash"`
	Blocknumber  pgtype.Int4 `json:"blocknumber"`
	IsCurrent    bool        `json:"is_current"`
	UserID       int32       `json:"user_id"`
	Referrer     pgtype.Int4 `json:"referrer"`
	IsMobileUser bool        `json:"is_mobile_user"`
	Slot         pgtype.Int4 `json:"slot"`
}

type UserListeningHistory struct {
	UserID           int32           `json:"user_id"`
	ListeningHistory json.RawMessage `json:"listening_history"`
}

type UserPayoutWalletHistory struct {
	UserID              int32       `json:"user_id"`
	SplUsdcPayoutWallet pgtype.Text `json:"spl_usdc_payout_wallet"`
	Blocknumber         int32       `json:"blocknumber"`
	BlockTimestamp      time.Time   `json:"block_timestamp"`
	CreatedAt           time.Time   `json:"created_at"`
}

type UserPubkey struct {
	UserID       int32  `json:"user_id"`
	PubkeyBase64 string `json:"pubkey_base64"`
}

type UserTip struct {
	Slot           int32     `json:"slot"`
	Signature      string    `json:"signature"`
	SenderUserID   int32     `json:"sender_user_id"`
	ReceiverUserID int32     `json:"receiver_user_id"`
	Amount         int64     `json:"amount"`
	CreatedAt      time.Time `json:"created_at"`
	UpdatedAt      time.Time `json:"updated_at"`
}

type ValidatorHistory struct {
	Rowid        int32          `json:"rowid"`
	Endpoint     string         `json:"endpoint"`
	EthAddress   string         `json:"eth_address"`
	CometAddress string         `json:"comet_address"`
	SpID         int64          `json:"sp_id"`
	ServiceType  string         `json:"service_type"`
	EventType    ValidatorEvent `json:"event_type"`
	EventTime    time.Time      `json:"event_time"`
	EventBlock   int64          `json:"event_block"`
}
