// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: get_undisbursed_challenges.sql

package dbv1

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getUndisbursedChallenges = `-- name: GetUndisbursedChallenges :many
SELECT
    users.handle,
    users.wallet,
    user_challenges.challenge_id,
    user_challenges.specifier
FROM user_challenges
JOIN users ON users.user_id = user_challenges.user_id
LEFT JOIN challenge_disbursements
    ON challenge_disbursements.challenge_id = user_challenges.challenge_id
    AND challenge_disbursements.specifier = user_challenges.specifier
WHERE
    challenge_disbursements.challenge_id IS NULL
    AND user_challenges.is_complete
    AND user_challenges.user_id = $1
    AND ($2::text = '' OR user_challenges.challenge_id = $2)
    AND ($3::text = '' OR user_challenges.specifier = $3)
`

type GetUndisbursedChallengesParams struct {
	UserID      int32  `json:"user_id"`
	ChallengeID string `json:"challenge_id"`
	Specifier   string `json:"specifier"`
}

type GetUndisbursedChallengesRow struct {
	Handle      pgtype.Text `json:"handle"`
	Wallet      pgtype.Text `json:"wallet"`
	ChallengeID string      `json:"challenge_id"`
	Specifier   string      `json:"specifier"`
}

func (q *Queries) GetUndisbursedChallenges(ctx context.Context, arg GetUndisbursedChallengesParams) ([]GetUndisbursedChallengesRow, error) {
	rows, err := q.db.Query(ctx, getUndisbursedChallenges, arg.UserID, arg.ChallengeID, arg.Specifier)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUndisbursedChallengesRow
	for rows.Next() {
		var i GetUndisbursedChallengesRow
		if err := rows.Scan(
			&i.Handle,
			&i.Wallet,
			&i.ChallengeID,
			&i.Specifier,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
