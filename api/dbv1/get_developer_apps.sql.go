// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: get_developer_apps.sql

package dbv1

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getDeveloperAppByAddress = `-- name: GetDeveloperAppByAddress :one
SELECT
  address,
  blockhash,
  blocknumber,
  user_id,
  name,
  is_personal_access,
  is_delete,
  created_at,
  txhash,
  is_current,
  updated_at,
  description,
  image_url
FROM developer_apps
WHERE 
  LOWER(address) = LOWER($1)
  AND is_current = true
  AND is_delete = false
LIMIT 1
`

func (q *Queries) GetDeveloperAppByAddress(ctx context.Context, address string) (DeveloperApp, error) {
	row := q.db.QueryRow(ctx, getDeveloperAppByAddress, address)
	var i DeveloperApp
	err := row.Scan(
		&i.Address,
		&i.Blockhash,
		&i.Blocknumber,
		&i.UserID,
		&i.Name,
		&i.IsPersonalAccess,
		&i.IsDelete,
		&i.CreatedAt,
		&i.Txhash,
		&i.IsCurrent,
		&i.UpdatedAt,
		&i.Description,
		&i.ImageUrl,
	)
	return i, err
}

const getDeveloperAppsByUser = `-- name: GetDeveloperAppsByUser :many
SELECT
  address,
  blockhash,
  blocknumber,
  user_id,
  name,
  is_personal_access,
  is_delete,
  created_at,
  txhash,
  is_current,
  updated_at,
  description,
  image_url
FROM developer_apps
WHERE 
  user_id = $1
  AND is_current = true
  AND is_delete = false
ORDER BY created_at DESC
`

func (q *Queries) GetDeveloperAppsByUser(ctx context.Context, userID *int32) ([]DeveloperApp, error) {
	rows, err := q.db.Query(ctx, getDeveloperAppsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeveloperApp
	for rows.Next() {
		var i DeveloperApp
		if err := rows.Scan(
			&i.Address,
			&i.Blockhash,
			&i.Blocknumber,
			&i.UserID,
			&i.Name,
			&i.IsPersonalAccess,
			&i.IsDelete,
			&i.CreatedAt,
			&i.Txhash,
			&i.IsCurrent,
			&i.UpdatedAt,
			&i.Description,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeveloperAppsWithGrantForUser = `-- name: GetDeveloperAppsWithGrantForUser :many
SELECT
  developer_apps.address,
  developer_apps.name,
  developer_apps.description,
  developer_apps.image_url,
  grants.user_id AS grantor_user_id,
  grants.created_at AS grant_created_at,
  grants.updated_at AS grant_updated_at
FROM developer_apps
LEFT JOIN grants ON grants.grantee_address = developer_apps.address
WHERE
  grants.user_id = $1
  AND grants.is_revoked = false
  AND grants.is_current = true
  AND developer_apps.is_current = true
  AND developer_apps.is_delete = false
ORDER BY grants.updated_at ASC
`

type GetDeveloperAppsWithGrantForUserRow struct {
	Address        string           `json:"address"`
	Name           string           `json:"name"`
	Description    *string          `json:"description"`
	ImageUrl       *string          `json:"image_url"`
	GrantorUserID  *int32           `json:"grantor_user_id"`
	GrantCreatedAt pgtype.Timestamp `json:"grant_created_at"`
	GrantUpdatedAt pgtype.Timestamp `json:"grant_updated_at"`
}

func (q *Queries) GetDeveloperAppsWithGrantForUser(ctx context.Context, userID int32) ([]GetDeveloperAppsWithGrantForUserRow, error) {
	rows, err := q.db.Query(ctx, getDeveloperAppsWithGrantForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeveloperAppsWithGrantForUserRow
	for rows.Next() {
		var i GetDeveloperAppsWithGrantForUserRow
		if err := rows.Scan(
			&i.Address,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.GrantorUserID,
			&i.GrantCreatedAt,
			&i.GrantUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
