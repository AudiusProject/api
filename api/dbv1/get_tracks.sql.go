// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: get_tracks.sql

package dbv1

import (
	"context"
	"encoding/json"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const getTracks = `-- name: GetTracks :many
WITH my_follows AS (
  SELECT
    followee_user_id as user_id,
    follower_count
  FROM follows
  JOIN aggregate_user ON followee_user_id = user_id
  WHERE $1 > 0
    AND follower_user_id = $1
    AND follows.is_delete = false
  ORDER BY follower_count DESC
  LIMIT 5000
)
SELECT
  t.track_id,
  description,
  genre,
  'hashid' as id,
  track_cid,
  preview_cid,
  orig_file_cid,
  orig_filename,
  is_original_available,
  mood,
  release_date,
  repost_count,
  save_count as favorite_count,
  comment_count,
  tags,
  title,
  track_routes.slug as slug,
  duration,
  is_downloadable,
  aggregate_plays.count as play_count,
  ddex_app,
  pinned_comment_id,
  playlists_containing_track,
  playlists_previously_containing_track,

  (
    SELECT json_build_object(
      'playlist_id', ab.playlist_id,
      'playlist_name', ab.playlist_name,
      'permalink', '/' || ab.handle || '/album/' || ab.slug
    )
    FROM (
      SELECT
        pt.track_id,
        p.playlist_id,
        p.playlist_name,
        u.handle,
        pr.slug
      FROM playlist_tracks pt
      JOIN playlists p ON p.playlist_id = pt.playlist_id
      JOIN users u ON u.user_id = p.playlist_owner_id AND u.is_current = true
      JOIN playlist_routes pr ON pr.playlist_id = p.playlist_id AND pr.is_current = true
      WHERE
        pt.track_id = t.track_id
        AND pt.is_removed = false
        AND p.is_album = true
        AND p.is_delete = false
        AND p.is_current = true
      ORDER BY pt.track_id, p.created_at DESC
      LIMIT 1
    ) ab
  )::jsonb AS album_backlink,

  t.blocknumber,
  create_date,
  t.created_at,
  cover_art_sizes,
  credits_splits,
  isrc,
  license,
  iswc,
  field_visibility,

  (
    SELECT EXISTS (
      SELECT 1
      FROM reposts
      WHERE $1 > 0
        AND user_id = $1
        AND repost_type = 'track'
        AND repost_item_id = t.track_id
        AND is_delete = false
    )
  ) AS has_current_user_reposted,

  (
    SELECT EXISTS (
      SELECT 1
      FROM saves
      WHERE $1 > 0
        AND user_id = $1
        AND save_type = 'track'
        AND save_item_id = t.track_id
        AND is_delete = false
    )
  ) AS has_current_user_saved,

  is_scheduled_release,
  is_unlisted,

  (
    SELECT json_agg(
      json_build_object(
        'user_id', r.user_id::text,
        'repost_item_id', repost_item_id::text, -- this is redundant
        'repost_type', 'RepostType.track', -- some sqlalchemy bs
        'created_at', r.created_at -- this is not actually present in python response?
      )
    )
    FROM (
      SELECT user_id, repost_item_id, reposts.created_at
      FROM reposts
      JOIN my_follows USING (user_id)
      WHERE repost_item_id = t.track_id
        AND repost_type = 'track'
        AND reposts.is_delete = false
      ORDER BY follower_count DESC
      LIMIT 3
    ) r
  )::jsonb as followee_reposts,

  (
    SELECT json_agg(
      json_build_object(
        'user_id', r.user_id::text,
        'favorite_item_id', r.save_item_id::text, -- this is redundant
        'favorite_type', 'SaveType.track', -- some sqlalchemy bs
        'created_at', r.created_at -- this is not actually present in python response?
      )
    )
    FROM (
      SELECT user_id, save_item_id, saves.created_at
      FROM saves
      JOIN my_follows USING (user_id)
      WHERE save_item_id = t.track_id
        AND save_type = 'track'
        AND saves.is_delete = false
      ORDER BY follower_count DESC
      LIMIT 3
    ) r
  )::jsonb as followee_favorites,

  (
    SELECT json_build_object(
      'tracks', json_agg(
        json_build_object(
          'has_remix_author_reposted', repost_item_id is not null,
          'has_remix_author_saved', save_item_id is not null,
          'parent_track_id', r.parent_track_id,
          'parent_user_id', r.parent_owner_id
        )
      )
    )
    FROM (
      SELECT
        track_id as parent_track_id,
        owner_id as parent_owner_id,
        repost_item_id,
        save_item_id
      FROM remixes
      JOIN tracks parent_track ON parent_track_id = parent_track.track_id AND child_track_id = t.track_id
      LEFT JOIN reposts ON repost_type = 'track' AND repost_item_id = t.track_id AND reposts.user_id = parent_track.owner_id AND reposts.is_delete = false
      LEFT JOIN saves ON save_type = 'track' AND save_item_id = t.track_id AND saves.user_id = parent_track.owner_id AND saves.is_delete = false
      LIMIT 10
    ) r
  )::jsonb as remix_of,

  stem_of,
  track_segments, -- todo: can we just get rid of this now?
  t.updated_at,
  t.owner_id as user_id,
  t.is_delete,
  cover_art,
  is_available,
  ai_attribution_user_id,
  allowed_api_keys,
  audio_upload_id,
  preview_start_seconds,
  bpm,
  is_custom_bpm,
  musical_key,
  is_custom_musical_key,
  audio_analysis_error_count,
  comments_disabled,
  ddex_release_ids,
  artists,
  resource_contributors,
  indirect_resource_contributors,
  rights_controller,
  copyright_line,
  producer_copyright_line,
  parental_warning_type,
  is_stream_gated,
  stream_conditions,
  is_download_gated,
  download_conditions,
  cover_original_song_title,
  cover_original_artist,
  is_owned_by_user

FROM tracks t
JOIN aggregate_track using (track_id)
LEFT JOIN aggregate_plays on play_item_id = t.track_id
LEFT JOIN track_routes on t.track_id = track_routes.track_id and track_routes.is_current = true
WHERE (is_unlisted = false OR t.owner_id = $1 OR $2::bool = TRUE)
  AND t.track_id = ANY($3::int[])
ORDER BY t.track_id
`

type GetTracksParams struct {
	MyID            interface{} `json:"my_id"`
	IncludeUnlisted bool        `json:"include_unlisted"`
	Ids             []int32     `json:"ids"`
}

type GetTracksRow struct {
	TrackID                            int32           `json:"track_id"`
	Description                        pgtype.Text     `json:"description"`
	Genre                              pgtype.Text     `json:"genre"`
	ID                                 string          `json:"id"`
	TrackCid                           pgtype.Text     `json:"track_cid"`
	PreviewCid                         pgtype.Text     `json:"preview_cid"`
	OrigFileCid                        pgtype.Text     `json:"orig_file_cid"`
	OrigFilename                       pgtype.Text     `json:"orig_filename"`
	IsOriginalAvailable                bool            `json:"is_original_available"`
	Mood                               pgtype.Text     `json:"mood"`
	ReleaseDate                        *time.Time      `json:"release_date"`
	RepostCount                        int32           `json:"repost_count"`
	FavoriteCount                      int32           `json:"favorite_count"`
	CommentCount                       pgtype.Int4     `json:"comment_count"`
	Tags                               pgtype.Text     `json:"tags"`
	Title                              pgtype.Text     `json:"title"`
	Slug                               pgtype.Text     `json:"slug"`
	Duration                           pgtype.Int4     `json:"duration"`
	IsDownloadable                     bool            `json:"is_downloadable"`
	PlayCount                          pgtype.Int8     `json:"play_count"`
	DdexApp                            pgtype.Text     `json:"ddex_app"`
	PinnedCommentID                    pgtype.Int4     `json:"pinned_comment_id"`
	PlaylistsContainingTrack           []int32         `json:"playlists_containing_track"`
	PlaylistsPreviouslyContainingTrack json.RawMessage `json:"playlists_previously_containing_track"`
	AlbumBacklink                      json.RawMessage `json:"album_backlink"`
	Blocknumber                        pgtype.Int4     `json:"blocknumber"`
	CreateDate                         pgtype.Text     `json:"create_date"`
	CreatedAt                          time.Time       `json:"created_at"`
	CoverArtSizes                      pgtype.Text     `json:"cover_art_sizes"`
	CreditsSplits                      pgtype.Text     `json:"credits_splits"`
	Isrc                               pgtype.Text     `json:"isrc"`
	License                            pgtype.Text     `json:"license"`
	Iswc                               pgtype.Text     `json:"iswc"`
	FieldVisibility                    json.RawMessage `json:"field_visibility"`
	HasCurrentUserReposted             bool            `json:"has_current_user_reposted"`
	HasCurrentUserSaved                bool            `json:"has_current_user_saved"`
	IsScheduledRelease                 bool            `json:"is_scheduled_release"`
	IsUnlisted                         bool            `json:"is_unlisted"`
	FolloweeReposts                    json.RawMessage `json:"followee_reposts"`
	FolloweeFavorites                  json.RawMessage `json:"followee_favorites"`
	RemixOf                            json.RawMessage `json:"remix_of"`
	StemOf                             []byte          `json:"stem_of"`
	TrackSegments                      json.RawMessage `json:"track_segments"`
	UpdatedAt                          time.Time       `json:"updated_at"`
	UserID                             int32           `json:"user_id"`
	IsDelete                           bool            `json:"is_delete"`
	CoverArt                           pgtype.Text     `json:"cover_art"`
	IsAvailable                        bool            `json:"is_available"`
	AiAttributionUserID                pgtype.Int4     `json:"ai_attribution_user_id"`
	AllowedApiKeys                     []string        `json:"allowed_api_keys"`
	AudioUploadID                      pgtype.Text     `json:"audio_upload_id"`
	PreviewStartSeconds                pgtype.Float8   `json:"preview_start_seconds"`
	Bpm                                pgtype.Float8   `json:"bpm"`
	IsCustomBpm                        pgtype.Bool     `json:"is_custom_bpm"`
	MusicalKey                         pgtype.Text     `json:"musical_key"`
	IsCustomMusicalKey                 pgtype.Bool     `json:"is_custom_musical_key"`
	AudioAnalysisErrorCount            int32           `json:"audio_analysis_error_count"`
	CommentsDisabled                   pgtype.Bool     `json:"comments_disabled"`
	DdexReleaseIds                     json.RawMessage `json:"ddex_release_ids"`
	Artists                            json.RawMessage `json:"artists"`
	ResourceContributors               json.RawMessage `json:"resource_contributors"`
	IndirectResourceContributors       json.RawMessage `json:"indirect_resource_contributors"`
	RightsController                   json.RawMessage `json:"rights_controller"`
	CopyrightLine                      json.RawMessage `json:"copyright_line"`
	ProducerCopyrightLine              json.RawMessage `json:"producer_copyright_line"`
	ParentalWarningType                pgtype.Text     `json:"parental_warning_type"`
	IsStreamGated                      pgtype.Bool     `json:"is_stream_gated"`
	StreamConditions                   *AccessGate     `json:"stream_conditions"`
	IsDownloadGated                    pgtype.Bool     `json:"is_download_gated"`
	DownloadConditions                 *AccessGate     `json:"download_conditions"`
	CoverOriginalSongTitle             pgtype.Text     `json:"cover_original_song_title"`
	CoverOriginalArtist                pgtype.Text     `json:"cover_original_artist"`
	IsOwnedByUser                      bool            `json:"is_owned_by_user"`
}

func (q *Queries) GetTracks(ctx context.Context, arg GetTracksParams) ([]GetTracksRow, error) {
	rows, err := q.db.Query(ctx, getTracks, arg.MyID, arg.IncludeUnlisted, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTracksRow
	for rows.Next() {
		var i GetTracksRow
		if err := rows.Scan(
			&i.TrackID,
			&i.Description,
			&i.Genre,
			&i.ID,
			&i.TrackCid,
			&i.PreviewCid,
			&i.OrigFileCid,
			&i.OrigFilename,
			&i.IsOriginalAvailable,
			&i.Mood,
			&i.ReleaseDate,
			&i.RepostCount,
			&i.FavoriteCount,
			&i.CommentCount,
			&i.Tags,
			&i.Title,
			&i.Slug,
			&i.Duration,
			&i.IsDownloadable,
			&i.PlayCount,
			&i.DdexApp,
			&i.PinnedCommentID,
			&i.PlaylistsContainingTrack,
			&i.PlaylistsPreviouslyContainingTrack,
			&i.AlbumBacklink,
			&i.Blocknumber,
			&i.CreateDate,
			&i.CreatedAt,
			&i.CoverArtSizes,
			&i.CreditsSplits,
			&i.Isrc,
			&i.License,
			&i.Iswc,
			&i.FieldVisibility,
			&i.HasCurrentUserReposted,
			&i.HasCurrentUserSaved,
			&i.IsScheduledRelease,
			&i.IsUnlisted,
			&i.FolloweeReposts,
			&i.FolloweeFavorites,
			&i.RemixOf,
			&i.StemOf,
			&i.TrackSegments,
			&i.UpdatedAt,
			&i.UserID,
			&i.IsDelete,
			&i.CoverArt,
			&i.IsAvailable,
			&i.AiAttributionUserID,
			&i.AllowedApiKeys,
			&i.AudioUploadID,
			&i.PreviewStartSeconds,
			&i.Bpm,
			&i.IsCustomBpm,
			&i.MusicalKey,
			&i.IsCustomMusicalKey,
			&i.AudioAnalysisErrorCount,
			&i.CommentsDisabled,
			&i.DdexReleaseIds,
			&i.Artists,
			&i.ResourceContributors,
			&i.IndirectResourceContributors,
			&i.RightsController,
			&i.CopyrightLine,
			&i.ProducerCopyrightLine,
			&i.ParentalWarningType,
			&i.IsStreamGated,
			&i.StreamConditions,
			&i.IsDownloadGated,
			&i.DownloadConditions,
			&i.CoverOriginalSongTitle,
			&i.CoverOriginalArtist,
			&i.IsOwnedByUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
