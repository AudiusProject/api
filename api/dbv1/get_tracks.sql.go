// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: get_tracks.sql

package dbv1

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const getTracks = `-- name: GetTracks :many
SELECT
  t.track_id,
  -- artwork,
  description,
  genre,
  'hashid' as id,
  track_cid,
  preview_cid,
  orig_file_cid,
  orig_filename,
  is_original_available,
  mood,
  release_date,
  remix_of,
  repost_count,
  save_count as favorite_count,
  comment_count,
  tags,
  title,
  track_routes.slug as slug,
  -- user,
  duration,
  is_downloadable,
  aggregate_plays.count as play_count,
  -- permalink,
  -- is_streamable,
  ddex_app,
  -- playlists_containing_track,
  pinned_comment_id,
  -- album_backlink,
  -- access,
  t.blocknumber,
  create_date,
  t.created_at,
  cover_art_sizes,
  -- cover_art_cids,
  credits_splits,
  isrc,
  license,
  iswc,
  field_visibility,
  -- followee_reposts,

  (
    SELECT count(*) > 0
    FROM reposts
    WHERE $1 > 0
      AND user_id = $1
      AND repost_type = 'track'
      AND repost_item_id = t.track_id
      AND is_delete = false
  ) AS has_current_user_reposted,

  (
    SELECT count(*) > 0
    FROM saves
    WHERE $1 > 0
      AND user_id = $1
      AND save_type = 'track'
      AND save_item_id = t.track_id
      AND is_delete = false
  ) AS has_current_user_saved,

  is_scheduled_release,
  is_unlisted,

  (
    SELECT json_agg(
      json_build_object(
        'user_id', r.user_id::text,
        'repost_item_id', repost_item_id::text, -- this is redundant
        'repost_type', 'RepostType.track', -- some sqlalchemy bs
        'created_at', r.created_at -- this is not actually present in python response?
      )
    )
    FROM (
      SELECT user_id, repost_item_id, reposts.created_at
      FROM reposts
      JOIN follows ON followee_user_id = reposts.user_id AND follower_user_id = $1
      JOIN aggregate_user USING (user_id)
      WHERE repost_item_id = t.track_id
        AND repost_type = 'track'
        AND reposts.is_delete = false
      ORDER BY follower_count DESC
      LIMIT 3
    ) r
  )::jsonb as followee_reposts,

  (
    SELECT json_agg(
      json_build_object(
        'user_id', r.user_id::text,
        'favorite_item_id', r.save_item_id::text, -- this is redundant
        'favorite_type', 'SaveType.track', -- some sqlalchemy bs
        'created_at', r.created_at -- this is not actually present in python response?
      )
    )
    FROM (
      SELECT user_id, save_item_id, saves.created_at
      FROM saves
      JOIN follows ON followee_user_id = saves.user_id AND follower_user_id = $1
      JOIN aggregate_user USING (user_id)
      WHERE save_item_id = t.track_id
        AND save_type = 'track'
        AND saves.is_delete = false
      ORDER BY follower_count DESC
      LIMIT 3
    ) r
  )::jsonb as followee_favorites,


  -- followee_favorites,
  -- route_id,
  stem_of,
  -- track_segments, todo: can we just get rid of this now?
  t.updated_at,
  t.owner_id as user_id,
  t.is_delete,
  cover_art,
  is_available,
  ai_attribution_user_id,
  allowed_api_keys,
  audio_upload_id,
  preview_start_seconds,
  bpm,
  is_custom_bpm,
  musical_key,
  is_custom_musical_key,
  audio_analysis_error_count,
  comments_disabled,
  ddex_release_ids,
  artists,
  resource_contributors,
  indirect_resource_contributors,
  rights_controller,
  copyright_line,
  producer_copyright_line,
  parental_warning_type,
  -- is_streamable,
  is_stream_gated,
  stream_conditions,
  is_download_gated,
  download_conditions,
  cover_original_song_title,
  is_owned_by_user

  -- stream,
  -- download,
  -- preview




FROM tracks t
JOIN aggregate_track using (track_id)
LEFT JOIN aggregate_plays on play_item_id = t.track_id
LEFT JOIN track_routes on t.track_id = track_routes.track_id and track_routes.is_current = true
WHERE is_available = true
  AND (is_unlisted = false OR t.owner_id = $1)
  AND t.track_id = ANY($2::int[])
ORDER BY t.track_id
`

type GetTracksParams struct {
	MyID interface{} `json:"my_id"`
	Ids  []int32     `json:"ids"`
}

type GetTracksRow struct {
	TrackID                      int32            `json:"track_id"`
	Description                  pgtype.Text      `json:"description"`
	Genre                        pgtype.Text      `json:"genre"`
	ID                           string           `json:"id"`
	TrackCid                     pgtype.Text      `json:"track_cid"`
	PreviewCid                   pgtype.Text      `json:"preview_cid"`
	OrigFileCid                  pgtype.Text      `json:"orig_file_cid"`
	OrigFilename                 pgtype.Text      `json:"orig_filename"`
	IsOriginalAvailable          bool             `json:"is_original_available"`
	Mood                         pgtype.Text      `json:"mood"`
	ReleaseDate                  pgtype.Timestamp `json:"release_date"`
	RemixOf                      []byte           `json:"remix_of"`
	RepostCount                  int32            `json:"repost_count"`
	FavoriteCount                int32            `json:"favorite_count"`
	CommentCount                 pgtype.Int4      `json:"comment_count"`
	Tags                         pgtype.Text      `json:"tags"`
	Title                        pgtype.Text      `json:"title"`
	Slug                         pgtype.Text      `json:"slug"`
	Duration                     pgtype.Int4      `json:"duration"`
	IsDownloadable               bool             `json:"is_downloadable"`
	PlayCount                    pgtype.Int8      `json:"play_count"`
	DdexApp                      pgtype.Text      `json:"ddex_app"`
	PinnedCommentID              pgtype.Int4      `json:"pinned_comment_id"`
	Blocknumber                  pgtype.Int4      `json:"blocknumber"`
	CreateDate                   pgtype.Text      `json:"create_date"`
	CreatedAt                    pgtype.Timestamp `json:"created_at"`
	CoverArtSizes                pgtype.Text      `json:"cover_art_sizes"`
	CreditsSplits                pgtype.Text      `json:"credits_splits"`
	Isrc                         pgtype.Text      `json:"isrc"`
	License                      pgtype.Text      `json:"license"`
	Iswc                         pgtype.Text      `json:"iswc"`
	FieldVisibility              json.RawMessage  `json:"field_visibility"`
	HasCurrentUserReposted       bool             `json:"has_current_user_reposted"`
	HasCurrentUserSaved          bool             `json:"has_current_user_saved"`
	IsScheduledRelease           bool             `json:"is_scheduled_release"`
	IsUnlisted                   bool             `json:"is_unlisted"`
	FolloweeReposts              json.RawMessage  `json:"followee_reposts"`
	FolloweeFavorites            json.RawMessage  `json:"followee_favorites"`
	StemOf                       []byte           `json:"stem_of"`
	UpdatedAt                    pgtype.Timestamp `json:"updated_at"`
	UserID                       int32            `json:"user_id"`
	IsDelete                     bool             `json:"is_delete"`
	CoverArt                     pgtype.Text      `json:"cover_art"`
	IsAvailable                  bool             `json:"is_available"`
	AiAttributionUserID          pgtype.Int4      `json:"ai_attribution_user_id"`
	AllowedApiKeys               []string         `json:"allowed_api_keys"`
	AudioUploadID                pgtype.Text      `json:"audio_upload_id"`
	PreviewStartSeconds          pgtype.Float8    `json:"preview_start_seconds"`
	Bpm                          pgtype.Float8    `json:"bpm"`
	IsCustomBpm                  pgtype.Bool      `json:"is_custom_bpm"`
	MusicalKey                   pgtype.Text      `json:"musical_key"`
	IsCustomMusicalKey           pgtype.Bool      `json:"is_custom_musical_key"`
	AudioAnalysisErrorCount      int32            `json:"audio_analysis_error_count"`
	CommentsDisabled             pgtype.Bool      `json:"comments_disabled"`
	DdexReleaseIds               json.RawMessage  `json:"ddex_release_ids"`
	Artists                      json.RawMessage  `json:"artists"`
	ResourceContributors         json.RawMessage  `json:"resource_contributors"`
	IndirectResourceContributors json.RawMessage  `json:"indirect_resource_contributors"`
	RightsController             json.RawMessage  `json:"rights_controller"`
	CopyrightLine                json.RawMessage  `json:"copyright_line"`
	ProducerCopyrightLine        json.RawMessage  `json:"producer_copyright_line"`
	ParentalWarningType          pgtype.Text      `json:"parental_warning_type"`
	IsStreamGated                pgtype.Bool      `json:"is_stream_gated"`
	StreamConditions             UsageConditions  `json:"stream_conditions"`
	IsDownloadGated              pgtype.Bool      `json:"is_download_gated"`
	DownloadConditions           UsageConditions  `json:"download_conditions"`
	CoverOriginalSongTitle       pgtype.Text      `json:"cover_original_song_title"`
	IsOwnedByUser                bool             `json:"is_owned_by_user"`
}

func (q *Queries) GetTracks(ctx context.Context, arg GetTracksParams) ([]GetTracksRow, error) {
	rows, err := q.db.Query(ctx, getTracks, arg.MyID, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTracksRow
	for rows.Next() {
		var i GetTracksRow
		if err := rows.Scan(
			&i.TrackID,
			&i.Description,
			&i.Genre,
			&i.ID,
			&i.TrackCid,
			&i.PreviewCid,
			&i.OrigFileCid,
			&i.OrigFilename,
			&i.IsOriginalAvailable,
			&i.Mood,
			&i.ReleaseDate,
			&i.RemixOf,
			&i.RepostCount,
			&i.FavoriteCount,
			&i.CommentCount,
			&i.Tags,
			&i.Title,
			&i.Slug,
			&i.Duration,
			&i.IsDownloadable,
			&i.PlayCount,
			&i.DdexApp,
			&i.PinnedCommentID,
			&i.Blocknumber,
			&i.CreateDate,
			&i.CreatedAt,
			&i.CoverArtSizes,
			&i.CreditsSplits,
			&i.Isrc,
			&i.License,
			&i.Iswc,
			&i.FieldVisibility,
			&i.HasCurrentUserReposted,
			&i.HasCurrentUserSaved,
			&i.IsScheduledRelease,
			&i.IsUnlisted,
			&i.FolloweeReposts,
			&i.FolloweeFavorites,
			&i.StemOf,
			&i.UpdatedAt,
			&i.UserID,
			&i.IsDelete,
			&i.CoverArt,
			&i.IsAvailable,
			&i.AiAttributionUserID,
			&i.AllowedApiKeys,
			&i.AudioUploadID,
			&i.PreviewStartSeconds,
			&i.Bpm,
			&i.IsCustomBpm,
			&i.MusicalKey,
			&i.IsCustomMusicalKey,
			&i.AudioAnalysisErrorCount,
			&i.CommentsDisabled,
			&i.DdexReleaseIds,
			&i.Artists,
			&i.ResourceContributors,
			&i.IndirectResourceContributors,
			&i.RightsController,
			&i.CopyrightLine,
			&i.ProducerCopyrightLine,
			&i.ParentalWarningType,
			&i.IsStreamGated,
			&i.StreamConditions,
			&i.IsDownloadGated,
			&i.DownloadConditions,
			&i.CoverOriginalSongTitle,
			&i.IsOwnedByUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
