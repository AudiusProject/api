-- name: GetPlaylists :many
WITH my_follows AS (
  SELECT
    followee_user_id as user_id,
    follower_count
  FROM follows
  JOIN aggregate_user ON followee_user_id = user_id
  WHERE @my_id > 0
    AND follower_user_id = @my_id
    AND follows.is_delete = false
  ORDER BY follower_count DESC
  LIMIT 5000
)
SELECT
  p.description,
  p.is_album,
  p.is_delete,
  p.is_image_autogenerated,
  p.is_private,
  p.is_scheduled_release,
  p.is_stream_gated,
  p.stream_conditions,
  p.upc,
  p.ddex_app,
  p.playlist_image_multihash as cover_art,
  p.playlist_image_sizes_multihash as cover_art_sizes,
  p.parental_warning_type,

  coalesce(playlist_image_sizes_multihash, playlist_image_multihash) as artwork,

  p.playlist_name,

  p.playlist_id,
  p.playlist_owner_id,
  p.playlist_contents,
  playlist_routes.slug as slug,

  p.blocknumber,

  repost_count,
  save_count as favorite_count,
  created_at,
  updated_at,
  release_date,

  (
    SELECT count(*) > 0
    FROM reposts
    WHERE @my_id > 0
      AND user_id = @my_id
      AND repost_type != 'track'
      AND repost_item_id = p.playlist_id
      AND is_delete = false
  ) AS has_current_user_reposted,

  (
    SELECT count(*) > 0
    FROM saves
    WHERE @my_id > 0
      AND user_id = @my_id
      AND save_type != 'track'
      AND save_item_id = p.playlist_id
      AND is_delete = false
  ) AS has_current_user_saved,


  (
    SELECT json_agg(
      json_build_object(
        'user_id', r.user_id::text,
        'repost_item_id', repost_item_id::text, -- this is redundant
        'repost_type', 'RepostType.track', -- some sqlalchemy bs
        'created_at', r.created_at -- this is not actually present in python response?
      )
    )
    FROM (
      SELECT user_id, repost_item_id, reposts.created_at
      FROM reposts
      JOIN my_follows USING (user_id)
      WHERE repost_item_id = p.playlist_id
        AND repost_type != 'track'
        AND reposts.is_delete = false
      ORDER BY follower_count DESC
      LIMIT 6
    ) r
  )::jsonb as followee_reposts,

  (
    SELECT json_agg(
      json_build_object(
        'user_id', r.user_id::text,
        'favorite_item_id', r.save_item_id::text, -- this is redundant
        'favorite_type', 'SaveType.track', -- some sqlalchemy bs
        'created_at', r.created_at -- this is not actually present in python response?
      )
    )
    FROM (
      SELECT user_id, save_item_id, saves.created_at
      FROM saves
      JOIN my_follows USING (user_id)
      WHERE save_item_id = p.playlist_id
        AND save_type != 'track'
        AND saves.is_delete = false
      ORDER BY follower_count DESC
      LIMIT 6
    ) r
  )::jsonb as followee_favorites

FROM playlists p
JOIN aggregate_playlist using (playlist_id)
LEFT JOIN playlist_routes on p.playlist_id = playlist_routes.playlist_id and playlist_routes.is_current = true
WHERE is_delete = false
  and p.playlist_id = ANY(@ids::int[])
;
