package api

import (
	"context"
	"encoding/csv"
	"os"
	"slices"
	"time"

	"github.com/jackc/pgx/v5"
)

var (
	userBaseRow = map[string]any{
		"user_id":              nil,
		"handle":               nil,
		"handle_lc":            nil,
		"wallet":               nil,
		"is_current":           true,
		"is_verified":          false,
		"created_at":           time.Now(),
		"updated_at":           time.Now(),
		"has_collectibles":     false,
		"txhash":               "tx1",
		"is_deactivated":       false,
		"is_available":         true,
		"is_storage_v2":        false,
		"allow_ai_attribution": false,
	}

	trackBaseRow = map[string]any{
		"blockhash":                             "block_abc123",
		"track_id":                              "@track_id",
		"is_current":                            true,
		"is_delete":                             false,
		"owner_id":                              "@owner_id",
		"title":                                 "@title",
		"genre":                                 "Electronic",
		"mood":                                  "Energetic",
		"created_at":                            time.Now(),
		"updated_at":                            time.Now(),
		"txhash":                                "tx_123abc",
		"is_unlisted":                           false,
		"is_available":                          true,
		"track_segments":                        "[]", // JSONB string
		"is_scheduled_release":                  false,
		"is_downloadable":                       false,
		"is_original_available":                 false,
		"playlists_containing_track":            "{}", // JSONB string
		"playlists_previously_containing_track": map[string]any{},
		"audio_analysis_error_count":            0,
		"is_owned_by_user":                      false,
		"stream_conditions":                     nil,
		"download_conditions":                   nil,
	}

	playlistBaseRow = map[string]any{
		// "playlist_id":       1,
		// "playlist_owner_id": 42,
		"is_album":               false,
		"is_private":             false,
		"playlist_contents":      "{}",
		"is_current":             true,
		"is_delete":              false,
		"created_at":             time.Now(),
		"updated_at":             time.Now(),
		"txhash":                 "0xabcde12345",
		"is_image_autogenerated": false,
		"is_scheduled_release":   false,
		"stream_conditions":      "{}",
	}

	followBaseRow = map[string]any{
		"blockhash":        "block1",
		"blocknumber":      101,
		"follower_user_id": nil,
		"followee_user_id": nil,
		"is_current":       true,
		"is_delete":        false,
		"created_at":       time.Now(),
		"txhash":           "tx123",
		"slot":             500,
	}

	repostBaseRow = map[string]any{
		"blockhash":           "block_abc123",
		"blocknumber":         101,
		"user_id":             nil,
		"repost_item_id":      nil,
		"repost_type":         nil,
		"is_current":          true,
		"is_delete":           false,
		"created_at":          time.Now(),
		"txhash":              "tx_456def",
		"slot":                500,
		"is_repost_of_repost": false,
	}

	developerAppBaseRow = map[string]any{
		"blockhash":   "block1",
		"blocknumber": 101,
		"user_id":     nil,
		"address":     "0x7d7b6b7a97d1deefe3a1ccc5a13c48e8f055e0b6",
		"name":        "Test Developer App",
		"description": "Test Description",
		"created_at":  time.Now(),
		"txhash":      "tx123",
		"is_current":  true,
		"updated_at":  time.Now(),
		"image_url":   nil,
	}

	trackTrendingScoreBaseRow = map[string]any{
		"track_id":   nil,
		"type":       "TRACKS",
		"genre":      nil,
		"version":    "pnagD",
		"time_range": nil,
		"score":      nil,
		"created_at": time.Now(),
	}

	connectedWalletsBaseRow = map[string]any{
		"id":          nil,
		"user_id":     nil,
		"wallet":      nil,
		"blockhash":   "block_abc123",
		"blocknumber": 101,
		"is_current":  true,
		"is_delete":   false,
		"chain":       nil,
	}

	aggregateUserTipsBaseRow = map[string]any{
		"sender_user_id":   nil,
		"receiver_user_id": nil,
		"amount":           1000,
	}

	usdcPurchaseBaseRow = map[string]any{
		"buyer_user_id":  nil,
		"seller_user_id": nil,
		"content_id":     nil,
		"content_type":   "track",
		"amount":         nil,
		"slot":           101,
		"signature":      nil,
		"splits":         "[]",
		"created_at":     time.Now(),
	}

	grantBaseRow = map[string]any{
		"blockhash":       "block1",
		"blocknumber":     101,
		"user_id":         nil,
		"is_current":      true,
		"grantee_address": nil,
		"is_approved":     false,
		"is_revoked":      false,
		"created_at":      time.Now(),
		"updated_at":      time.Now(),
		"txhash":          "tx123",
	}

	trackRouteBaseRow = map[string]any{
		"slug":         nil,
		"title_slug":   nil,
		"collision_id": nil,
		"owner_id":     nil,
		"track_id":     nil,
		"is_current":   true,
		"blockhash":    "block_abc123",
		"blocknumber":  101,
		"txhash":       "tx123",
	}

	playlistRouteBaseRow = map[string]any{
		"slug":         nil,
		"title_slug":   nil,
		"collision_id": nil,
		"owner_id":     nil,
		"playlist_id":  nil,
		"is_current":   true,
		"blockhash":    "block_abc123",
		"blocknumber":  101,
		"txhash":       "tx123",
	}
)

func insertFixtures(table string, baseRow map[string]any, csvFile string) {
	file, err := os.Open(csvFile)
	checkErr(err)
	defer file.Close()

	reader := csv.NewReader(file)
	rows, err := reader.ReadAll()
	checkErr(err)
	csvHeader := rows[0]

	// union baseRow keys with csv header for field list
	fieldList := []string{}
	for f := range baseRow {
		fieldList = append(fieldList, f)
	}
	for _, f := range csvHeader {
		if !slices.Contains(fieldList, f) {
			fieldList = append(fieldList, f)
		}
	}

	var records [][]any
	for _, row := range rows[1:] {
		thisRow := map[string]any{}
		for i, field := range csvHeader {
			if row[i] != "" {
				thisRow[field] = row[i]
			}
		}

		vals := []any{}
		for _, field := range fieldList {
			val := baseRow[field]
			if v, ok := thisRow[field]; ok {
				val = v
			}
			vals = append(vals, val)
		}
		records = append(records, vals)
	}

	_, err = app.pool.CopyFrom(
		context.Background(),
		pgx.Identifier{table},
		fieldList,
		pgx.CopyFromRows(records),
	)
	checkErr(err)
}
